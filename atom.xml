<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[JiangNan's Blog]]></title>
  <subtitle><![CDATA[筚路蓝缕，以启山林]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://jiangnan31.github.io/"/>
  <updated>2015-10-01T05:43:29.867Z</updated>
  <id>http://jiangnan31.github.io/</id>
  
  <author>
    <name><![CDATA[JiangNan]]></name>
    <email><![CDATA[jiangnan31@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[流与文件 <三> IO编解码]]></title>
    <link href="http://jiangnan31.github.io/2015/09/20/%E6%B5%81%E4%B8%8E%E6%96%87%E4%BB%B6-%E4%B8%89-IO%E7%BC%96%E8%A7%A3%E7%A0%81/"/>
    <id>http://jiangnan31.github.io/2015/09/20/流与文件-三-IO编解码/</id>
    <published>2015-09-20T02:29:42.000Z</published>
    <updated>2015-10-01T05:43:29.867Z</updated>
    <content type="html"><![CDATA[<h2 id="1、字节字符转化：InputStreamReader、_OutputStreamWriter">1、字节字符转化：InputStreamReader、 OutputStreamWriter</h2><h3 id="1-1_转化过程">1.1 转化过程</h3><p><img src="/img/io/intout.jpg" alt="转化步骤"><br><a id="more"></a><br>数据持久化或网络传输都是以字节进行的，所以必须要进行字符到字节或字节到字符的转化。以操作文件为例，内存中的字符数据需要通过OutputStreamWriter变为字节流才能保存在文件中，读取时需要将读入的字节流通过InputStreamReader变为字符流。</p>
<h3 id="1-2_适配器模式">1.2 适配器模式</h3><p><img src="/img/io/adapter.png" alt="适配器的作用"><br>如上图所示，适配器能够不改变原有代码，将现有系统的请求转换成厂商能够理解的请求。<br><img src="/img/io/adapter2.png" alt="适配器模式"><br>如图所示，适配器对象将实现目标接口，并持有被适配对象。</p>
<p>我们拿火鸡对象来冒充缺少的鸭子对象时：TurkeyAdapter实现鸭子接口（以火鸡的行为替代鸭子的行为），持有火鸡对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> headfirst.adapter.ducks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> headfirst.adapter.ducks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> headfirst.adapter.ducks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">	Turkey turkey;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		turkey.gobble();</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			turkey.fly();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> headfirst.adapter.ducks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Gobble gobble"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"I'm flying a short distance"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3_字符转字节_|_写入_|_编码_|_OutputStreamWriter">1.3 字符转字节 | 写入 | 编码 | OutputStreamWriter</h3><p>OutputStreamWriter将使用选定的字符编码方式，将字符流转化为字节流<br><img src="/img/io/outputstreamwriter.png" alt="OutputStreamWriter类结构图"><br>OutputStreamWriter实现了Writer接口，同时通过StreamEncoder间接持有了InputStream的引用，OutputStreamWriter使用OutputStream的行为来替代了Writer的行为。（当然没有那么简单，中间有涉及到StreamEncoder进行char到byte的编码）</p>
<p>StreamEncoder中流程间较多，可以调试查看。。。好吧，我承认我没看懂。。。</p>
<h3 id="1-4_字节转字符_|_读取_|_解码_|_InputStreamReader">1.4 字节转字符 | 读取 | 解码 | InputStreamReader</h3><p>InputStreamReader将使用选定的字符编码方式，将字节流转化为字符流<br><img src="/img/io/inputstreamreader.png" alt="InputStreamReader类结构图"><br>InputStreamReader实现了Reader接口，同时通过StreamDecoder间接持有了InputStream的引用，InputStreamReader使用InputStream的行为来替代了Reader的行为。（当然中间也涉及到StreamDecoder进行byte到char的解码）</p>
<h3 id="1-5_装饰者模式">1.5 装饰者模式</h3><p><img src="/img/io/decorator.png" alt="headfirst decorator"><br><strong>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的.</strong><br>Java io中的装饰者： <a href="http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi/#Java中的装饰者" target="_blank" rel="external">详情</a><br><strong>注： 类图有些缺失，FilterInputStream持有InputStream对象实例引用的关系未标明。</strong></p>
<p>装饰者模式vs适配器模式</p>
<p>适配器模式：将一个接口转换为另一个接口，通过改变接口来达到重复使用的目的。{鸭子不足，通过用火鸡代替鸭子的方式来鸭子的可重复使用？}<br>装饰者模式：不改变被装饰者对象的接口，保持原有的接口，但要增强原有对象的功能，或改变原有对象的处理方法。</p>
<p>参考文献：<br>[1] <a href="http://davidisok.iteye.com/blog/2106489" target="_blank" rel="external">Java IO 详解</a><br>[2] <a href="http://blog.sina.com.cn/s/blog_5920510a0101ijj5.html" target="_blank" rel="external">JAVA字符串与字符编码处理的终极解决</a><br>[3] <a href="http://book.douban.com/subject/3360866/" target="_blank" rel="external">JAVA核心技术卷2</a><br>[4] <a href="http://book.douban.com/subject/25953851/" target="_blank" rel="external">深入分析java web技术内幕</a><br>[5] <a href="http://book.douban.com/subject/2243615/" target="_blank" rel="external">Head First 设计模式</a><br>[6] <a href="http://blog.csdn.net/crave_shy/article/details/17239313" target="_blank" rel="external">Java_io体系之OutputStreamWriter、InputStreamReader简介、走进源码及示例——17</a><br>[7] <a href="http://www.cnblogs.com/mengdd/archive/2013/02/12/2910302.html" target="_blank" rel="external">Java IO 装饰者模式</a><br>[8] <a href="http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi/" target="_blank" rel="external">装饰者模式</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1、字节字符转化：InputStreamReader、_OutputStreamWriter">1、字节字符转化：InputStreamReader、 OutputStreamWriter</h2><h3 id="1-1_转化过程">1.1 转化过程</h3><p><img src="/img/io/intout.jpg" alt="转化步骤"><br>]]>
    
    </summary>
    
      <category term="IO" scheme="http://jiangnan31.github.io/tags/IO/"/>
    
      <category term="整理" scheme="http://jiangnan31.github.io/categories/%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[流与文件 <二> 流]]></title>
    <link href="http://jiangnan31.github.io/2015/09/13/%E6%B5%81%E4%B8%8E%E6%96%87%E4%BB%B6-%E4%BA%8C-%E6%B5%81/"/>
    <id>http://jiangnan31.github.io/2015/09/13/流与文件-二-流/</id>
    <published>2015-09-13T01:50:44.000Z</published>
    <updated>2015-10-01T05:31:44.080Z</updated>
    <content type="html"><![CDATA[<h2 id="1、简介">1、简介</h2><p>在面向字节的流中，可以从其中读入一个字节序列的对象称为输入流，向其中写入一个字节序列的对象称为输入流。字节序列的来源和目的地可以是文件，也可以是网络连接，甚至是内存块。<br>但面向字节的流不便于处理以字符形式（每个字符均由多个字节表示）存储信息，所以我们需要有面向字符的流。<br><a id="more"></a><br><img src="/img/io/classify.jpg" alt="Java IO"></p>
<p>如上图所示，按照传输数据的数据格式的不同分为两种，分别为字符流、字节流。</p>
<p><img src="/img/io/all_class.png" alt="简易版类图"><br>简单版类图中仅展示了接口与继承关系，未对依赖关系进行描述。从类图中可以看出顶层接口有 Flushable（刷新数据的目标地，调用 flush 方法将所有已缓冲输出写入底层流。）、Closeable（关闭的数据源或目标，调用 close 方法可释放对象保存的资源。）、serializable（启用其序列化功能。序列化接口没有方法或字段，仅用于标识可序列化的语义。）。</p>
<h2 id="2、字节流_：_InputStream_、OutputStream">2、字节流 ： InputStream 、OutputStream</h2><p><img src="/img/io/inputstream.png" alt="InputStream相关类图"><br>InputStream相关类图如上图所示，其中主要包含有 FileInputStream（从文件系统中的某个文件中获得输入字节）、FilterInputStream（数据流的过滤）、ObjectInputStream（恢复序列化的对象）、PipedInputStream（管道输入流，多线程通过管道进行线程间通信）、SequenceInputStream、<del>StringBufferInputStream</del>、ByteArrayInputStream(包含一个内部缓冲区，缓冲区中有从流中读取的字节。)。</p>
<p><img src="/img/io/outputstream.png" alt="OutputStream相关类图"><br>OutputStream相关类图如上图所示，其中包含有FileOutputStream、FilterOutputStream、ObjectOutputStream、ByteArrayOutputStream等</p>
<h2 id="3、字符流_：_Reader、Writer">3、字符流 ： Reader、Writer</h2><p><img src="/img/io/reader.png" alt="Reader相关类图"><br>Reader相关类图如上图所示，BufferedReader（从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。）、FilterReader（读取已过滤的字符流）、CharArrayReader（实现用作字符输入流的字符缓冲区）、PipedReader、<strong>InputStreamReader（字节转字符，使用指定的 charset 读取字节并将其解码为字符。）</strong>、StringReader。</p>
<p><img src="/img/io/writer.png" alt="Writer相关类图"></p>
<p>Writer相关类图如上图所示，BufferedWriter（从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。）、FilterWriter（读取已过滤的字符流）、CharArrayWriter（实现用作字符输入流的字符缓冲区）、PipedWriter、<strong>OutputStreamWriter（字符转字节，使用指定的 charset 将要写入流中的字符编码成字节。）</strong>、StringReader。</p>
<p>参考文献：<br>[1] <a href="http://davidisok.iteye.com/blog/2106489" target="_blank" rel="external">Java IO 详解</a><br>[2] <a href="http://blog.sina.com.cn/s/blog_5920510a0101ijj5.html" target="_blank" rel="external">JAVA字符串与字符编码处理的终极解决</a><br>[3] <a href="http://book.douban.com/subject/3360866/" target="_blank" rel="external">JAVA核心技术卷2</a><br>[4] <a href="http://book.douban.com/subject/25953851/" target="_blank" rel="external">深入分析java web技术内幕</a><br>[5] <a href="http://book.douban.com/subject/2243615/" target="_blank" rel="external">Head First 设计模式</a><br>[6] <a href="http://blog.csdn.net/crave_shy/article/details/17239313" target="_blank" rel="external">Java_io体系之OutputStreamWriter、InputStreamReader简介、走进源码及示例——17</a><br>[7] <a href="http://www.cnblogs.com/mengdd/archive/2013/02/12/2910302.html" target="_blank" rel="external">Java IO 装饰者模式</a><br>[8] <a href="http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi/" target="_blank" rel="external">装饰者模式</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1、简介">1、简介</h2><p>在面向字节的流中，可以从其中读入一个字节序列的对象称为输入流，向其中写入一个字节序列的对象称为输入流。字节序列的来源和目的地可以是文件，也可以是网络连接，甚至是内存块。<br>但面向字节的流不便于处理以字符形式（每个字符均由多个字节表示）存储信息，所以我们需要有面向字符的流。<br>]]>
    
    </summary>
    
      <category term="IO" scheme="http://jiangnan31.github.io/tags/IO/"/>
    
      <category term="整理" scheme="http://jiangnan31.github.io/categories/%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[流与文件 <一>   编码简介]]></title>
    <link href="http://jiangnan31.github.io/2015/09/08/%E6%B5%81%E4%B8%8E%E6%96%87%E4%BB%B6-%E4%B8%80-%E7%BC%96%E7%A0%81%E7%AE%80%E4%BB%8B/"/>
    <id>http://jiangnan31.github.io/2015/09/08/流与文件-一-编码简介/</id>
    <published>2015-09-08T06:52:15.000Z</published>
    <updated>2015-09-14T02:37:24.451Z</updated>
    <content type="html"><![CDATA[<h2 id="为什么要进行编码">为什么要进行编码</h2><p>计算机无法理解我们人类使用的语言，只能识别0或者1。所以，为了使计算机能够理解我们所使用的语言，我们需要通过翻译的过程，将其翻译成计算机能够理解的语言。这个翻译的过程就是编码。多数计算机使用8位的块，或者字节（byte）作为最小的可寻址的存储器单位，而不是在存储器中访问单独的位。<br><a id="more"></a><br>因此我们可知：<br>1、计算机中存储信息的最小单元是一个字节即 8 个 bit，所以能表示的字符范围是 0~255 个<br>2、人类要表示的符号太多，无法用一个字节来完全表示<br>3、要解决这个矛盾必须需要一个新的数据结构 char，从 char 到 byte 必须编码</p>
<h2 id="常用编码格式">常用编码格式</h2><ul>
<li><p>ASCII 码<br>标准ASCII 码也叫基础ASCII码，使用字节低7 位二进制数来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符。0~31 是控制字符如换行回车删除等；32~126 是打印字符，可以通过键盘输入并且能够显示出来。</p>
</li>
<li><p>ISO-8859-1<br>以ASCII为基础，在空置的0xA0-0xFF的范围内，加入96个字母及符号，涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。</p>
</li>
<li><p>GB2312 &amp; GBK<br>双字节编码，GBK兼容GB2312 ，可以用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。</p>
</li>
<li><p>UTF-8 &amp; UTF-16 &amp; UTF-32<br>Unicode将世界上所有的符号都纳入其中，每一个符号都给予一个独一无二的编码。但它只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储实现。<br>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示）。<br>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。<br>链接：（  <a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">Unicode存在的问题  |  Unicode与UTF-8之间的转换</a>）</p>
</li>
</ul>
<p>参考文献：<br>[1] <a href="http://lavasoft.blog.51cto.com/62575/273608" target="_blank" rel="external">Java字符编码根本原理</a><br>[2] <a href="http://blog.sina.com.cn/s/blog_5920510a0101ijj5.html" target="_blank" rel="external">JAVA字符串与字符编码处理的终极解决</a><br>[3] <a href="http://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/" target="_blank" rel="external">深入分析 Java 中的中文编码问题</a><br>[4] <a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记：ASCII，Unicode和UTF-8</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="为什么要进行编码">为什么要进行编码</h2><p>计算机无法理解我们人类使用的语言，只能识别0或者1。所以，为了使计算机能够理解我们所使用的语言，我们需要通过翻译的过程，将其翻译成计算机能够理解的语言。这个翻译的过程就是编码。多数计算机使用8位的块，或者字节（byte）作为最小的可寻址的存储器单位，而不是在存储器中访问单独的位。<br>]]>
    
    </summary>
    
      <category term="IO" scheme="http://jiangnan31.github.io/tags/IO/"/>
    
      <category term="整理" scheme="http://jiangnan31.github.io/categories/%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重新出发]]></title>
    <link href="http://jiangnan31.github.io/2015/09/06/%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/"/>
    <id>http://jiangnan31.github.io/2015/09/06/重新出发/</id>
    <published>2015-09-06T09:22:30.000Z</published>
    <updated>2015-09-06T10:34:15.181Z</updated>
    <content type="html"><![CDATA[<p>我是个懒惰的人，很不好意思我没有能够把博客坚持下去。重新出发，我会积极努力！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我是个懒惰的人，很不好意思我没有能够把博客坚持下去。重新出发，我会积极努力！</p>
]]>
    </summary>
    
      <category term="扯犊子" scheme="http://jiangnan31.github.io/categories/%E6%89%AF%E7%8A%8A%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Zookeeper学习与使用(转载)]]></title>
    <link href="http://jiangnan31.github.io/2015/03/08/Zookeeper%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://jiangnan31.github.io/2015/03/08/Zookeeper学习与使用/</id>
    <published>2015-03-08T14:09:00.000Z</published>
    <updated>2015-09-05T04:34:36.553Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_ZooKeeper的学习与应用">1. ZooKeeper的学习与应用</h2><h3 id="1-1-_概述">1.1. 概述</h3><p>ZooKeeper是Apache在很多云计算项目中的一个，与Hadoop密切相关，这种情况导致我一开始认为ZooKeeper的搭建需要Hadoop项目作为支持，但是最后发现完全不需要，它是可以单独运行的一个项目。</p>
<p>在网上看到了一个很不错的关于ZooKeeper的介绍： 顾名思义<span style="color:red">动物园管理员，他是拿来管大象(Hadoop) 、 蜜蜂(Hive) 、 小猪(Pig)  的管理员</span>， Apache Hbase和 Apache Solr 以及LinkedIn sensei  等项目中都采用到了 Zookeeper。ZooKeeper是一个分布式的，<span style="color:red">开放源码的分布式应用程序协调服务</span>，ZooKeeper是以Fast Paxos算法为基础，实现<span style="color:red">同步服务，配置维护和命名服务</span>等分布式应用。</p>
<a id="more"></a>
<p>从介绍可以看出，ZooKeeper更倾向于对大型应用的协同维护管理工作。IBM则给出了IBM对ZooKeeper的认知： Zookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些<span style="color:red">数据管理问题</span>，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>
<p>总之，我认为它的核心词就是一个单词，协调。</p>
<h2 id="1-2-_ZooKeeper的特征">1.2. ZooKeeper的特征</h2><p> 在Hadoop权威指南中看到了关于ZooKeeper的一些核心特征，阅读之后感觉总结的甚是精辟，在这里引用并总结。</p>
<h3 id="1-2-1-_简易">1.2.1. 简易</h3><p>ZooKeeper的最重要核心就是一个精简文件系统，提供一些简单的操作以及附加的抽象（例如排序和通知）。</p>
<h3 id="1-2-2-_易表达">1.2.2. 易表达</h3><p>ZooKeeper的原型是一个丰富的集合，它们是一些已建好的块，可以用来构建大型的协作数据结构和协议，例如：分布式队列、分布式锁以及一组对等体的选举。</p>
<h3 id="1-2-3-_高可用性">1.2.3. 高可用性</h3><p>ZooKeeper运行在一些集群上，被设计成可用性较高的，因此应用程序可以依赖它。ZooKeeper可以帮助你的系统<span style="color:red">避免单点故障</span>，从而建立一个可靠的应用程序。</p>
<h3 id="1-2-4-_松散耦合">1.2.4. 松散耦合</h3><p>ZooKeeper的交互支持参与者之间并不了解对方。例如：ZooKeeper可以被当做一种公共的机制，使得进程彼此不知道对方的存在也可以相互发现并且交互，对等方可能甚至不是同步的。</p>
<p>这一特点我感觉最能体现在集群的部署启动过程中。像Hadoop当把配置文件写好之后，然后运行启动脚本，则251，241，242中作为集群的虚拟机是同步启动的，也就是<span style="color:red">DataNode，NameNode，TaskTracker，以及JobTracker的启动并运行时在一次启动过程中启动的，就是运行一次启动脚本文件，则都启动起来</span>。但是ZooKeeper的启动过程却不是这样的。我在251，241，242部署了ZooKeeper集群，并进行启动，则启动的过程是这样的：首先ssh到251然后启动，这时候251的集群节点启动起来，但是控制台一直报错，大概的含义就是没有检测到其他两个结点。接着分别ssh到241，242，分别启动集群中的剩下的结点，当241启动起来时，回到251查看，发现报错的信息减少，意思是只差一个结点。当251，241，242三台服务器的结点全部启动起来，则三台的服务器的控制台打印出正常的信息。</p>
<h3 id="1-2-5-_ZooKeeper是一个库">1.2.5. ZooKeeper是一个库</h3><p>ZooKeeper提供了一个开源的、共享的执行存储，以及通用协作的方法，分担了每个程序员写通用协议的负担。随着时间的推移，人们可以增加和改进这个库来满足自己的需求。</p>
<h2 id="1-3-_Zookeeper基本知识">1.3. Zookeeper基本知识</h2><p>在这一小结，我介绍关于ZooKeeper的一些基本理论知识，以便对ZooKeeper有一个基本感性的认识吧，由于学习的时间不长，有些的认识可能是比较片面的，之后如果有了更深层次的认识，会补充于之后的月总结中。</p>
<h3 id="1-3-1-_层次化的名字空间">1.3.1. 层次化的名字空间</h3><p>ZooKeeper的整个名字空间的结构是层次化的，和一般的Linux文件系统结构非常相似，一颗很大的树。这也就是ZooKeeper的数据结构情况。名字空间的层次由斜杠/来进行分割，在名称空间里面的每一个结点的名字空间唯一由这个结点的路径来确定。<br><img src="/img/distributed _systems/zookeeper/3_1.jpg" alt=""><br>图3.1 ZooKeeper的层次化名字空间（原图丢失，自己配图）</p>
<p>每一个节点拥有自身的一些信息，包括：数据、数据长度、创建时间、修改时间等等。从这样一类既含有数据，又作为路径表标示的节点的特点中，可以看出，ZooKeeper的节点<span style="color:red">既可以被看做是一个文件，又可以被看做是一个目录，它同时具有二者的特点</span>。为了便于表达，今后我们将使用Znode来表示所讨论的ZooKeeper节点。</p>
<h3 id="1-3-2-_Znode">1.3.2. Znode</h3><p>Znode维护着<span style="color:red">数据、ACL（access control list，访问控制列表）、时间戳等交换版本号等数据结构</span>，它通过对这些数据的管理来让缓存生效并且令协调更新。每当Znode中的数据更新后它所维护的版本号将增加，这非常类似于数据库中计数器时间戳的操作方式。</p>
<p>另外Znode还具有<span style="color:red">原子性</span>操作的特点：命名空间中，每一个Znode的数据将被原子地读写。读操作将读取与Znode相关的所有数据，写操作将替换掉所有的数据。除此之外，每一个节点都有一个访问控制列表，这个访问控制列表规定了用户操作的权限。</p>
<p>ZooKeeper中同样存在临时节点。这些节点与session同时存在，当session生命周期结束，这些临时节点也将被删除。临时节点在某些场合也发挥着非常重要的作用。</p>
<h3 id="1-3-3-_Watch机制">1.3.3. Watch机制</h3><p>Watch机制就和单词本身的意思一样，看。看什么？具体来讲就是某一个或者一些Znode的变化。官方给出的定义：一个Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端，以便通知它们。</p>
<p>Watch机制主要有以下三个特点：</p>
<p>1、一次性的触发器（one-time trigger）<br>    当数据改变的时候，那么一个Watch事件会产生并且被发送到客户端中。但是客户端只会收到一次这样的通知，如果以后这个数据再次发生改变的时候，之前设置Watch的客户端将不会再次收到改变的通知，因为Watch机制规定了它是一个一次性的触发器。</p>
<p>2、发送给客户端<br>    这个表明了Watch的通知事件是从服务器发送给客户端的，是异步的，这就表明不同的客户端收到的Watch的时间可能不同，但是ZooKeeper有保证：<span style="color:red">当一个客户端在看到Watch事件之前是不会看到结点数据的变化的</span>。例如：A=3，此时在上面设置了一次Watch，如果A突然变成4了，那么客户端会先收到Watch事件的通知，然后才会看到A=4。</p>
<p>3、被设置Watch的数据<br>    这表明了一个结点可以变换的不同方式。一个Znode变化方式有两种，<span style="color:red">结点本身数据的变化以及结点孩子的变化</span>。因此Watch也可以设置为这个Znode的结点数据，当然也可以设置为Znode结点孩子。</p>
<h3 id="1-3-4-_ACL访问控制列表">1.3.4. ACL访问控制列表</h3><p>这是另外一个和Linux操作系统非常相似的地方，ZooKeeper使用ACL来控制对旗下Znode结点们的访问。ACL（access control list，访问控制列表）的实现和Linux文件系统的访问权限十分类似：它通过设置权限为来表明是否允许对一个结点的相关内容的改变。</p>
<p>但是与传统Linux机制不太相同，一个结点的数据没有类似“拥有者，组用户，其他用户”的概念，在ZooKeeper中，ACL通过设置ID以及与其关联的权限来完成访问控制的。ACL的权限组成语法是：<br>(scheme:expression, perms)<br>前者表明设置的ID，逗号后面表示的是ID相关的权限，例如：<br> (ip:172.16.16.1, READ)<br>指明了IP地址为如上的用户的权限为只读。</p>
<p>以下列举以下ACL所具有的权限</p>
<blockquote>
<ul>
<li>CREATE：表明你可以创建一个Znode的子结点。</li>
<li>READ：你可以得到这个结点的数据以及列举该结点的子结点情况。</li>
<li>WRITE：设置一个结点的数据。</li>
<li>DELETE：可以删除一个结点</li>
<li>ADMIN：对一个结点设置权限。</li>
</ul>
</blockquote>
<h2 id="1-4-_ZooKeeper的部署以及简单使用">1.4. ZooKeeper的部署以及简单使用</h2><p>要想使用ZooKeeper，首先就要把它部署在服务器上跑起来，就想Apache，Tomcat，FtpServer等服务器一样。ZooKeeper的部署方式主要有三种，单机模式、伪集群模式、集群模式。其实剩下的两种模式都是集群模式的特殊情况。</p>
<h3 id="1-4-1-_基本的环境变量配置">1.4.1. 基本的环境变量配置</h3><p>Java大型的项目中，环境变量的配置很重要，如果没有很好的配置环境变量的话，甚至项目连启动都是难事。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ZOOKEEPER_HOME=/home/zookeeper-<span class="number">3.3</span>.3</span><br><span class="line">export PATH=$PATH:$ZOOKEEPER_HOME/bin:$ZOOKEEPER_HOME/conf</span><br></pre></td></tr></table></figure>
<h3 id="1-4-2-_ZooKeeper的单机模式部署">1.4.2. ZooKeeper的单机模式部署</h3><p>ZooKeeper的单机模式通常是用来快速测试客户端应用程序的，在实际过程中不可能是单机模式。单机模式的配置也比较简单。</p>
<h4 id="l、编写配置文件zoo-cfg">l、编写配置文件zoo.cfg</h4><p>zookeeper-3.3.3/conf文件夹下面就是要编写配置文件的位置了。在文件夹下面新建一个文件zoo.cfg。ZooKeeper的运行默认是读取zoo.cfg文件里面的内容的。以下是一个最简单的配置文件的样例：<br>tickTime=2000<br>dataDir=/var/zookeeper<br>clientPort=2181</p>
<p>在这个文件中，我们需要指定 dataDir 的值，它指向了一个目录，这个目录在开始的时候需要为空。下面是每个参数的含义：<br>tickTime ：基本事件单元，以毫秒为单位。这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是<span style="color:red">每个 tickTime 时间就会发送一个心跳。</span><br>dataDir ：存储内存中数据库快照的位置，顾名思义就是 <span style="color:red">Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。</span><br><span style="color:red">clientPort ：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</span></p>
<p>使用单机模式时用户需要注意：这种配置方式下没有 ZooKeeper 副本，所以如果 ZooKeeper 服务器出现故障， ZooKeeper 服务将会停止。</p>
<h4 id="2、_执行运行脚本">2、 执行运行脚本</h4><p>在zookeeper-3.3.3/bin文件夹下面运行zkServer.sh即可，运行完毕之后则ZooKeeper服务变启动起来。<br>./zkServer.sh start<br>脚本默认调用zoo.cfg里面的配置，因此程序正常启动。</p>
<h3 id="1-4-3-_ZooKeeper的集群模式部署">1.4.3. ZooKeeper的集群模式部署</h3><p>ZooKeeper的集群模式下，多个Zookeeper服务器在工作前会选举出一个Leader，在接下来的工作中这个被选举出来的Leader死了，而剩下的Zookeeper服务器会知道这个Leader死掉了，在活着的Zookeeper集群中会继续选出一个Leader，选举出Leader的目的是为了<span style="color:red">可以在分布式的环境中保证数据的一致性。</span><br>如图所示：<br><img src="/img/distributed _systems/zookeeper/3_2.jpg" alt=""><br>图3.2 ZooKeeper集群模式图（原图丢失，自己配图）</p>
<h4 id="1、确认集群服务器的数量">1、确认集群服务器的数量</h4><p>由于ZooKeeper集群中，会有一个Leader负责管理和协调其他集群服务器，因此服务器的数量通常都是单数，例如3，5，7…等，这样2n+1的数量的服务器就可以允许最多n台服务器的失效。</p>
<h4 id="2、编写配置文件">2、编写配置文件</h4><p>配置文件需要在每台服务器中都要编写，以下是一个配置文件的样本：</p>
<h1 id="Filename_zoo-cfg">Filename zoo.cfg</h1><p>tickTime=2000<br>dataDir=/var/zookeeper/<br>clientPort=2181<br>initLimit=5<br>syncLimit=2<br>server.1=202.115.36.251:2888:3888<br>server.2=202.115.36.241:2888:3888<br>server.3=202.115.36.242:2888:3888</p>
<p>initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端<span style="color:red">不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器</span>）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒。</p>
<p>syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒<br>    server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</p>
<h4 id="3、创建myid文件">3、创建myid文件</h4><p>除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就只有一个数据就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。</p>
<h4 id="4、执行运行脚本">4、执行运行脚本</h4><p>和单机模式下的运行方式基本相同，值得注意的地方就是要分别在不同服务器上执行一次，例如分别在251，241，242上运行：<br>./zkServer.sh start<br>这样才能使得整个集群启动起来。</p>
<h3 id="1-4-4-_ZooKeeper的集群伪分布">1.4.4. ZooKeeper的集群伪分布</h3><p>其实在企业中式不会存在的，另外为了测试一个客户端程序也没有必要存在，只有在物质条件比较匮乏的条件下才会存在的模式。<br>集群伪分布模式就是在单机下模拟集群的ZooKeeper服务，在一台机器上面有多个ZooKeeper的JVM同时运行。</p>
<h4 id="1、确认集群伪服务器的数量">1、确认集群伪服务器的数量</h4><p>2n+1，和之前的集群分布相同。</p>
<h4 id="2、编写配置文件-1">2、编写配置文件</h4><p>在/conf文件夹新建三个配置文件，zoo1.cfg，zoo2.cfg以及zoo3.cfg。配置文件分别如下编写：<br>zoo1.cfg<br>tickTime=2000<br>initLimit=10<br>syncLimit=5<br>dataDir=/home/users/jiangnan04/tmp/zookeeper_test/d_1<br>clientPort=2181<br>server.1=localhost:2887:3887<br>server.2=localhost:2888:3888<br>server.3=localhost:2889:3889</p>
<p>zoo2.cfg<br>tickTime=2000<br>initLimit=10<br>syncLimit=5<br>dataDir=/home/users/jiangnan04/tmp/zookeeper_test/d_2<br>clientPort=2182<br>server.1=localhost:2887:3887<br>server.2=localhost:2888:3888<br>server.3=localhost:2889:3889<br>zoo3.cfg<br>tickTime=2000<br>initLimit=10<br>syncLimit=5<br>dataDir=/home/users/jiangnan04/tmp/zookeeper_test/d_3<br>clientPort=2183<br>server.1=localhost:2887:3887<br>server.2=localhost:2888:3888<br>server.3=localhost:2889:3889</p>
<p>由于三个服务都在同一台电脑上，因此这里要保证地址的唯一性，因此要特别注意IP地址和端口号不要互相冲突，以免影响程序的正确执行。</p>
<h4 id="3、创建myid文件-1">3、创建myid文件</h4><p>这个同集群模式部署，在各自的文件夹下面创建。</p>
<hr>
<p>除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就只有一个数据就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。</p>
<h4 id="4、执行运行脚本-1">4、执行运行脚本</h4><p>由于所有的配置文件都在/conf文件夹下面，因此要执行三次，而且要加文件名的参数，不然会默认执行zoo.cfg这个文件，如下：<br>./zkServer.sh start zoo1.cfg<br>./zkServer.sh start zoo2.cfg<br>./zkServer.sh start zoo3.cfg<br>执行完毕后，将完成ZooKeeper的集群伪分布的启动。</p>
<h3 id="1-4-5-_通过ZooKeeper命令行工具访问ZooKeeper">1.4.5. 通过ZooKeeper命令行工具访问ZooKeeper</h3><p>ZooKeeper命令行工具类似于Linux的shell环境，不过功能肯定不及shell啦，但是使用它我们可以简单的对ZooKeeper进行访问，数据创建，数据修改等操作。</p>
<p>当启动 ZooKeeper 服务成功之后，输入下述命令，连接到 ZooKeeper 服务：<br>zkCli.sh –server 127.0.0.1:2181<br>连接成功后，系统会输出 ZooKeeper 的相关环境以及配置信息，并在屏幕输出“ Welcome to ZooKeeper ”等信息。<br>命令行工具的一些简单操作如下：</p>
<blockquote>
<ul>
<li>使用 ls 命令来查看当前 ZooKeeper 中所包含的内容：<br>[zk: 10.94.44.42:2181(CONNECTED) 1] ls /</li>
<li>创建一个新的 znode ，使用 create /zk myData 。这个命令创建了一个新的 znode 节点“ zk ”以及与它关联的字符串：<br>[zk: 10.94.44.42:2181(CONNECTED) 2] create /zk “myData”</li>
<li>我们运行 get 命令来确认 znode 是否包含我们所创建的字符串：<br>[zk: 10.94.44.42:2181(CONNECTED) 3] get /zk</li>
<li>下面我们通过 set 命令来对 zk 所关联的字符串进行设置：<br>[zk: 10.94.44.42:2181(CONNECTED) 4] set /zk “zsl”</li>
<li>下面我们将刚才创建的 znode 删除：<br>[zk: 10.94.44.42:2181(CONNECTED) 5] delete /zk</li>
</ul>
</blockquote>
<h3 id="1-4-6-_使用API来访问ZooKeeper">1.4.6. 使用API来访问ZooKeeper</h3><p>API访问ZooKeeper才是客户端主要的使用手段，通过在客户端编写丰富多彩的程序，来达到对ZooKeeper的利用。这里给出一个简单的例子：（深入的还没能力给出啊，例子是从网上找的很清晰明了）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs.Ids;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 会话超时时间，设置为与系统默认时间一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT=<span class="number">30000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 ZooKeeper 实例</span></span><br><span class="line">    ZooKeeper zk;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建 Watcher 实例</span></span><br><span class="line">    Watcher wh=<span class="keyword">new</span> Watcher()&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(org.apache.zookeeper.WatchedEvent event)</span></span><br><span class="line">           </span>&#123;</span><br><span class="line">                   System.out.println(event.toString());</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 初始化 ZooKeeper 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createZKInstance</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">    </span>&#123;             </span><br><span class="line">           zk=<span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:2181"</span>,demo.SESSION_TIMEOUT,<span class="keyword">this</span>.wh);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ZKOperations</span><span class="params">()</span> <span class="keyword">throws</span> IOException,InterruptedException,KeeperException</span><br><span class="line">    </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"\n1. 创建 ZooKeeper 节点 (znode ： zoo2, 数据： myData2 ，权限： OPEN_ACL_UNSAFE ，节点类型： Persistent"</span>);</span><br><span class="line">           zk.create(<span class="string">"/zoo2"</span>,<span class="string">"myData2"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">          </span><br><span class="line">           System.out.println(<span class="string">"\n2. 查看是否创建成功： "</span>);</span><br><span class="line">           System.out.println(<span class="keyword">new</span> String(zk.getData(<span class="string">"/zoo2"</span>,<span class="keyword">false</span>,<span class="keyword">null</span>)));</span><br><span class="line">                          </span><br><span class="line">           System.out.println(<span class="string">"\n3. 修改节点数据 "</span>);</span><br><span class="line">           zk.setData(<span class="string">"/zoo2"</span>, <span class="string">"shenlan211314"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line">          </span><br><span class="line">           System.out.println(<span class="string">"\n4. 查看是否修改成功： "</span>);</span><br><span class="line">           System.out.println(<span class="keyword">new</span> String(zk.getData(<span class="string">"/zoo2"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>)));</span><br><span class="line">                          </span><br><span class="line">           System.out.println(<span class="string">"\n5. 删除节点 "</span>);</span><br><span class="line">           zk.delete(<span class="string">"/zoo2"</span>, -<span class="number">1</span>);</span><br><span class="line">          </span><br><span class="line">           System.out.println(<span class="string">"\n6. 查看节点是否被删除： "</span>);</span><br><span class="line">           System.out.println(<span class="string">" 节点状态： ["</span>+zk.exists(<span class="string">"/zoo2"</span>, <span class="keyword">false</span>)+<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ZKClose</span><span class="params">()</span> <span class="keyword">throws</span>  InterruptedException</span><br><span class="line">    </span>&#123;</span><br><span class="line">           zk.close();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,InterruptedException,KeeperException </span>&#123;</span><br><span class="line">           demo dm=<span class="keyword">new</span> demo();</span><br><span class="line">           dm.createZKInstance( );</span><br><span class="line">           dm.ZKOperations();</span><br><span class="line">           dm.ZKClose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此类包含两个主要的 ZooKeeper 函数，分别为 createZKInstance （）和 ZKOperations （）。其中 createZKInstance （）函数负责对 ZooKeeper 实例 zk 进行初始化。 ZooKeeper 类有两个构造函数，我们这里使用  “ ZooKeeper （ String connectString, ， int sessionTimeout, ， Watcher watcher ）”对其进行初始化。因此，我们需要提供初始化所需的，连接字符串信息，会话超时时间，以及一个 watcher 实例。 17 行到 23 行代码，是程序所构造的一个 watcher 实例，它能够输出所发生的事件。</p>
<p>ZKOperations （）函数是我们所定义的对节点的一系列操作。它包括：创建 ZooKeeper 节点（ 33 行到 34 行代码）、查看节点（ 36 行到 37 行代码）、修改节点数据（ 39 行到 40 行代码）、查看修改后节点数据（ 42 行到 43 行代码）、删除节点（ 45 行到 46 行代码）、查看节点是否存在（ 48 行到 49 行代码）。另外，需要注意的是：在创建节点的时候，需要提供节点的名称、数据、权限以及节点类型。此外，使用 exists 函数时，如果节点不存在将返回一<br>个 null 值。</p>
<h2 id="1-5-_小结">1.5. 小结</h2><pre><code>对于ZooKeeper的认识目前处在比较浅显的状态，了解到了基本的服务的部署以及大概ZooKeeper的工作原理。很多东西都是只懂得皮毛，现在能够深深地感受到“只有结合具体的应用才能使你对一个东西有较深的了解”这句话的深刻含义了。
</code></pre><p>转载自 ： <a href="http://blog.csdn.net/rengq126/article/details/7393227" target="_blank" rel="external">http://blog.csdn.net/rengq126/article/details/7393227</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_ZooKeeper的学习与应用">1. ZooKeeper的学习与应用</h2><h3 id="1-1-_概述">1.1. 概述</h3><p>ZooKeeper是Apache在很多云计算项目中的一个，与Hadoop密切相关，这种情况导致我一开始认为ZooKeeper的搭建需要Hadoop项目作为支持，但是最后发现完全不需要，它是可以单独运行的一个项目。</p>
<p>在网上看到了一个很不错的关于ZooKeeper的介绍： 顾名思义<span style="color:red">动物园管理员，他是拿来管大象(Hadoop) 、 蜜蜂(Hive) 、 小猪(Pig)  的管理员</span>， Apache Hbase和 Apache Solr 以及LinkedIn sensei  等项目中都采用到了 Zookeeper。ZooKeeper是一个分布式的，<span style="color:red">开放源码的分布式应用程序协调服务</span>，ZooKeeper是以Fast Paxos算法为基础，实现<span style="color:red">同步服务，配置维护和命名服务</span>等分布式应用。</p>]]>
    
    </summary>
    
      <category term="Distributed" scheme="http://jiangnan31.github.io/tags/Distributed/"/>
    
      <category term="转载" scheme="http://jiangnan31.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java 多线程<八> 并发协作 生产者消费者模型&&死锁]]></title>
    <link href="http://jiangnan31.github.io/2014/12/10/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%AB/"/>
    <id>http://jiangnan31.github.io/2014/12/10/java-多线程-八/</id>
    <published>2014-12-10T05:34:25.000Z</published>
    <updated>2015-09-05T03:40:14.803Z</updated>
    <content type="html"><![CDATA[<h1 id="并发协作-生产者消费者模型">并发协作-生产者消费者模型</h1><p>对于多线程程序来说，不管任何编程语言，生产者和消费者模型都是最经典的。就像学习每一门编程语言一样，Hello World！都是最经典的例子。</p>
<p>实际上，准确说应该是“生产者-消费者-仓储”模型，离开了仓储，生产者消费者模型就显得没有说服力了。<br>对于此模型，应该明确一下几点：</p>
<blockquote>
<ul>
<li>1、生产者仅仅在仓储未满时候生产，仓满则停止生产。</li>
<li>2、消费者仅仅在仓储有产品时候才能消费，仓空则等待。</li>
<li><span style="color:red"> 3、当消费者发现仓储没产品可消费时候会通知生产者生产。</span></li>
<li>4、生产者在生产出可消费产品时候，应该通知等待的消费者去消费。<br> </li>
</ul>
</blockquote>
<p>此模型将要结合java.lang.Object的wait与notify、notifyAll方法来实现以上的需求。这是非常重要的。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 仓库</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Godown</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> max_size = <span class="number">100</span>; <span class="comment">// 最大库存量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> curnum; <span class="comment">// 当前库存量</span></span><br><span class="line"></span><br><span class="line">	Godown() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Godown(<span class="keyword">int</span> curnum) &#123;</span><br><span class="line">		<span class="keyword">this</span>.curnum = curnum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 生产指定数量的产品</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> neednum</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> neednum)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 测试是否需要生产</span></span><br><span class="line">		<span class="keyword">while</span> (neednum + curnum &gt; max_size) &#123;</span><br><span class="line">			System.out.println(<span class="string">"要生产的产品数量"</span> + neednum + <span class="string">"超过剩余仓库空间"</span></span><br><span class="line">					+ (max_size - curnum) + <span class="string">"，暂时不能执行生产任务!"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 当前的生产线程等待</span></span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 满足生产条件，则进行生产，这里简单的更改当前库存量</span></span><br><span class="line">		curnum += neednum;</span><br><span class="line">		System.out.println(<span class="string">"已经生产了"</span> + neednum + <span class="string">"个产品，现仓储量为"</span> + curnum);</span><br><span class="line">		<span class="comment">// 唤醒在此对象监视器上等待的所有线程</span></span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 消费指定数量的产品</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> neednum</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> neednum)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 测试是否可消费</span></span><br><span class="line">		<span class="keyword">while</span> (curnum &lt; neednum) &#123;</span><br><span class="line">			System.out.println(<span class="string">"欲消费量"</span>+neednum+<span class="string">" 超过库存量"</span>+curnum+<span class="string">"，不可进行消费"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 当前的生产线程等待</span></span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 满足消费条件，则进行消费，这里简单的更改当前库存量</span></span><br><span class="line">		curnum -= neednum;</span><br><span class="line">		System.out.println(<span class="string">"已经消费了"</span> + neednum + <span class="string">"个产品，现仓储量为"</span> + curnum);</span><br><span class="line">		<span class="comment">// 唤醒在此对象监视器上等待的所有线程</span></span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 生产者</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> neednum; <span class="comment">// 生产产品的数量</span></span><br><span class="line">	<span class="keyword">private</span> Godown godown; <span class="comment">// 仓库</span></span><br><span class="line"></span><br><span class="line">	Producer(<span class="keyword">int</span> neednum, Godown godown) &#123;</span><br><span class="line">		<span class="keyword">this</span>.neednum = neednum;</span><br><span class="line">		<span class="keyword">this</span>.godown = godown;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 生产指定数量的产品</span></span><br><span class="line">		godown.produce(neednum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 消费者</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> neednum; <span class="comment">// 生产产品的数量</span></span><br><span class="line">	<span class="keyword">private</span> Godown godown; <span class="comment">// 仓库</span></span><br><span class="line"></span><br><span class="line">	Consumer(<span class="keyword">int</span> neednum, Godown godown) &#123;</span><br><span class="line">		<span class="keyword">this</span>.neednum = neednum;</span><br><span class="line">		<span class="keyword">this</span>.godown = godown;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 消费指定数量的产品</span></span><br><span class="line">		godown.consume(neednum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Godown godown = <span class="keyword">new</span> Godown(<span class="number">30</span>);</span><br><span class="line">		Consumer c1 = <span class="keyword">new</span> Consumer(<span class="number">50</span>, godown);</span><br><span class="line">		Consumer c2 = <span class="keyword">new</span> Consumer(<span class="number">20</span>, godown);</span><br><span class="line">		Consumer c3 = <span class="keyword">new</span> Consumer(<span class="number">30</span>, godown);</span><br><span class="line">		Producer p1 = <span class="keyword">new</span> Producer(<span class="number">10</span>, godown);</span><br><span class="line">		Producer p2 = <span class="keyword">new</span> Producer(<span class="number">10</span>, godown);</span><br><span class="line">		Producer p3 = <span class="keyword">new</span> Producer(<span class="number">10</span>, godown);</span><br><span class="line">		Producer p4 = <span class="keyword">new</span> Producer(<span class="number">10</span>, godown);</span><br><span class="line">		Producer p5 = <span class="keyword">new</span> Producer(<span class="number">10</span>, godown);</span><br><span class="line">		Producer p6 = <span class="keyword">new</span> Producer(<span class="number">10</span>, godown);</span><br><span class="line">		Producer p7 = <span class="keyword">new</span> Producer(<span class="number">80</span>, godown);</span><br><span class="line"></span><br><span class="line">		c1.start();</span><br><span class="line">		c2.start();</span><br><span class="line">		c3.start();</span><br><span class="line">		p1.start();</span><br><span class="line">		p2.start();</span><br><span class="line">		p3.start();</span><br><span class="line">		p4.start();</span><br><span class="line">		p5.start();</span><br><span class="line">		p6.start();</span><br><span class="line">		p7.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Result:</strong><br>欲消费量50 超过库存量30，不可进行消费<br>已经生产了10个产品，现仓储量为40<br>已经生产了10个产品，现仓储量为50<br>已经消费了30个产品，现仓储量为20<br>已经生产了10个产品，现仓储量为30<br>已经消费了20个产品，现仓储量为10<br>已经生产了10个产品，现仓储量为20<br>已经生产了10个产品，现仓储量为30<br>欲消费量50 超过库存量30，不可进行消费<br>已经生产了10个产品，现仓储量为40<br>欲消费量50 超过库存量40，不可进行消费<br>要生产的产品数量80超过剩余仓库空间60，暂时不能执行生产任务!</p>
<p>说明：<br>对于本例，要说明的是当发现不能满足生产或者消费条件的时候，调用对象的wait方法，wait方法的作用是释放当前线程的所获得的锁，并调用对象的notifyAll() 方法，通知（唤醒）该对象上其他等待线程，使得其继续执行。这样，整个生产者、消费者线程得以正确的协作执行。<br><span style="color:red">notifyAll() 方法，起到的是一个通知作用，不释放锁，也不获取锁。只是告诉该对象上等待的线程“可以竞争执行了，都醒来去执行吧”。</span></p>
<p>本例仅仅是生产者消费者模型中最简单的一种表示，本例中，如果消费者消费的仓储量达不到满足，而又没有生产者，则程序会一直处于等待状态，这当然是不对的。实际上可以将此例进行修改，修改为，根据消费驱动生产，同时生产兼顾仓库，如果仓不满就生产，并对每次最大消费量做个限制，这样就不存在此问题了，当然这样的例子更复杂，更难以说明这样一个简单模型。</p>
<h1 id="并发协作-死锁">并发协作-死锁</h1><p>线程发生死锁可能性很小，即使看似可能发生死锁的代码，在运行时发生死锁的可能性也是小之又小。</p>
<p>发生死锁的原因一般是两个对象的锁相互等待造成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> DeadlockRisk dead;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line">	MyThread(DeadlockRisk dead, <span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">		<span class="keyword">this</span>.dead = dead;</span><br><span class="line">		<span class="keyword">this</span>.a = a;</span><br><span class="line">		<span class="keyword">this</span>.b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dead.read();</span><br><span class="line">		dead.write(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadlockRisk</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Resource resourceA = <span class="keyword">new</span> Resource();</span><br><span class="line">	<span class="keyword">private</span> Resource resourceB = <span class="keyword">new</span> Resource();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">			System.out.println(<span class="string">"read():"</span> + Thread.currentThread().getName()</span><br><span class="line">					+ <span class="string">"获取了resourceA的锁！"</span>);</span><br><span class="line">			<span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">				System.out.println(<span class="string">"read():"</span> + Thread.currentThread().getName()</span><br><span class="line">						+ <span class="string">"获取了resourceB的锁！"</span>);</span><br><span class="line">				<span class="keyword">return</span> resourceB.value + resourceA.value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">			System.out.println(<span class="string">"write():"</span> + Thread.currentThread().getName()</span><br><span class="line">					+ <span class="string">"获取了resourceA的锁！"</span>);</span><br><span class="line">			<span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">				System.out.println(<span class="string">"write():"</span></span><br><span class="line">						+ Thread.currentThread().getName() + <span class="string">"获取了resourceB的锁！"</span>);</span><br><span class="line">				resourceA.value = a;</span><br><span class="line">				resourceB.value = b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DeadlockRisk dead = <span class="keyword">new</span> DeadlockRisk();</span><br><span class="line">		MyThread t1 = <span class="keyword">new</span> MyThread(dead, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		MyThread t2 = <span class="keyword">new</span> MyThread(dead, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">		MyThread t3 = <span class="keyword">new</span> MyThread(dead, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">		MyThread t4 = <span class="keyword">new</span> MyThread(dead, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">		t4.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Result:</strong><br>read():Thread-0获取了resourceA的锁！<br>read():Thread-0获取了resourceB的锁！<br>write():Thread-0获取了resourceA的锁！<br>read():Thread-3获取了resourceA的锁！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="并发协作-生产者消费者模型">并发协作-生产者消费者模型</h1><p>对于多线程程序来说，不管任何编程语言，生产者和消费者模型都是最经典的。就像学习每一门编程语言一样，Hello World！都是最经典的例子。</p>
<p>实际上，准确说应该是“生产者-消费者-仓储”模型，离开了仓储，生产者消费者模型就显得没有说服力了。<br>对于此模型，应该明确一下几点：</p>
<blockquote>
<ul>
<li>1、生产者仅仅在仓储未满时候生产，仓满则停止生产。</li>
<li>2、消费者仅仅在仓储有产品时候才能消费，仓空则等待。</li>
<li><span style="color:red"> 3、当消费者发现仓储没产品可消费时候会通知生产者生产。</li>
<li>4、生产者在生产出可消费产品时候，应该通知等待的消费者去消费。<br></span> </li>
</ul>
</blockquote>
<p>此模型将要结合java.lang.Object的wait与notify、notifyAll方法来实现以上的需求。这是非常重要的。<br>]]>
    
    </summary>
    
      <category term="Concurrency" scheme="http://jiangnan31.github.io/tags/Concurrency/"/>
    
      <category term="转载" scheme="http://jiangnan31.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java 多线程<七> 线程的同步 同步方法&同步块]]></title>
    <link href="http://jiangnan31.github.io/2014/12/10/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%83/"/>
    <id>http://jiangnan31.github.io/2014/12/10/java-多线程-七/</id>
    <published>2014-12-10T01:55:06.000Z</published>
    <updated>2015-09-05T03:39:49.347Z</updated>
    <content type="html"><![CDATA[<h1 id="线程的同步-同步方法">线程的同步-同步方法</h1><p>线程的同步是<span style="color:red">保证多线程安全访问竞争资源的一种手段。</span><br>线程的同步是Java多线程编程的难点，往往开发者搞不清楚什么是竞争资源、什么时候需要考虑同步，怎么同步等等问题，当然，这些问题没有很明确的答案，但有些原则问题需要考虑，是否有竞争资源被同时改动的问题？</p>
<p>在本文之前，请参阅《Java线程：线程的同步与锁》，本文是在此基础上所写的。<br><a id="more"></a><br>对于同步，在具体的Java代码中需要完成一下两个操作：<br><span style="color:red"><br>把竞争访问的资源标识为private；<br>同步哪些修改变量的代码，使用synchronized关键字同步方法或代码。<br>当然这不是唯一控制并发安全的途径。<br></span></p>
<p>synchronized关键字使用说明<br>synchronized只能标记非抽象的方法，不能标识成员变量。</p>
<p>为了演示同步方法的使用，构建了一个信用卡账户，起初信用额为100w，然后模拟透支、存款等多个操作。显然银行账户User对象是个竞争资源，而多个并发操作的是账户方法oper(int x)，当然应该在此方法上加上同步，并将账户的余额设为私有变量，禁止直接访问。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String code;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> cash;</span><br><span class="line"></span><br><span class="line">	User(String code, <span class="keyword">int</span> cash) &#123;</span><br><span class="line">		<span class="keyword">this</span>.code = code;</span><br><span class="line">		<span class="keyword">this</span>.cash = cash;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.code = code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">oper</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">			<span class="keyword">this</span>.cash += x;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"运行结束，增加“"</span></span><br><span class="line">					+ x + <span class="string">"”，当前用户账户余额为："</span> + cash);</span><br><span class="line">			Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"User&#123;"</span> + <span class="string">"code='"</span> + code + <span class="string">'\''</span> + <span class="string">", cash="</span> + cash + <span class="string">'&#125;'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> User u;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	MyThread(String name, User u, <span class="keyword">int</span> y) &#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.u = u;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		u.oper(y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		User u = <span class="keyword">new</span> User(<span class="string">"张三"</span>, <span class="number">100</span>);</span><br><span class="line">		MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">"线程A"</span>, u, <span class="number">20</span>);</span><br><span class="line">		MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">"线程B"</span>, u, -<span class="number">60</span>);</span><br><span class="line">		MyThread t3 = <span class="keyword">new</span> MyThread(<span class="string">"线程C"</span>, u, -<span class="number">80</span>);</span><br><span class="line">		MyThread t4 = <span class="keyword">new</span> MyThread(<span class="string">"线程D"</span>, u, -<span class="number">30</span>);</span><br><span class="line">		MyThread t5 = <span class="keyword">new</span> MyThread(<span class="string">"线程E"</span>, u, <span class="number">32</span>);</span><br><span class="line">		MyThread t6 = <span class="keyword">new</span> MyThread(<span class="string">"线程F"</span>, u, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">		t4.start();</span><br><span class="line">		t5.start();</span><br><span class="line">		t6.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">输出结果：</span><br><span class="line">线程A运行结束，增加“<span class="number">20</span>”，当前用户账户余额为：<span class="number">120</span> </span><br><span class="line">线程F运行结束，增加“<span class="number">21</span>”，当前用户账户余额为：<span class="number">141</span> </span><br><span class="line">线程E运行结束，增加“<span class="number">32</span>”，当前用户账户余额为：<span class="number">173</span> </span><br><span class="line">线程C运行结束，增加“-<span class="number">80</span>”，当前用户账户余额为：<span class="number">93</span> </span><br><span class="line">线程B运行结束，增加“-<span class="number">60</span>”，当前用户账户余额为：<span class="number">33</span> </span><br><span class="line">线程D运行结束，增加“-<span class="number">30</span>”，当前用户账户余额为：<span class="number">3</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">反面教材，不同步的情况，也就是去掉oper(<span class="keyword">int</span> x)方法的<span class="keyword">synchronized</span>修饰符，然后运行程序，结果如下：</span><br><span class="line">线程A运行结束，增加“<span class="number">20</span>”，当前用户账户余额为：<span class="number">61</span> </span><br><span class="line">线程D运行结束，增加“-<span class="number">30</span>”，当前用户账户余额为：<span class="number">63</span> </span><br><span class="line">线程B运行结束，增加“-<span class="number">60</span>”，当前用户账户余额为：<span class="number">3</span> </span><br><span class="line">线程F运行结束，增加“<span class="number">21</span>”，当前用户账户余额为：<span class="number">61</span> </span><br><span class="line">线程E运行结束，增加“<span class="number">32</span>”，当前用户账户余额为：<span class="number">93</span> </span><br><span class="line">线程C运行结束，增加“-<span class="number">80</span>”，当前用户账户余额为：<span class="number">61</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">很显然，上面的结果是错误的，导致错误的原因是多个线程并发访问了竞争资源u，并对u的属性做了改动。</span><br><span class="line"> </span><br><span class="line">可见同步的重要性。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">注意：</span><br><span class="line">通过前文可知，线程退出同步方法时将释放掉方法所属对象的锁，但还应该注意的是，同步方法中还可以使用特定的方法对线程进行调度。这些方法来自于java.lang.Object类。</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span>    </span><br><span class="line">                    唤醒在此对象监视器上等待的单个线程。    </span><br><span class="line"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span>    </span><br><span class="line">                    唤醒在此对象监视器上等待的所有线程。    </span><br><span class="line"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span>    </span><br><span class="line">                    导致当前的线程等待，直到其他线程调用此对象的 <span class="title">notify</span><span class="params">()</span> 方法或 <span class="title">notifyAll</span><span class="params">()</span> 方法。    </span><br><span class="line"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span>    </span><br><span class="line">                    导致当前的线程等待，直到其他线程调用此对象的 <span class="title">notify</span><span class="params">()</span> 方法或 <span class="title">notifyAll</span><span class="params">()</span> 方法，或者超过指定的时间量。    </span><br><span class="line"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span>    </span><br><span class="line">                    导致当前的线程等待，直到其他线程调用此对象的 <span class="title">notify</span><span class="params">()</span> 方法或 <span class="title">notifyAll</span><span class="params">()</span> 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</span><br><span class="line"> </span><br><span class="line">结合以上方法，处理多线程同步与互斥问题非常重要，著名的生产者-消费者例子就是一个经典的例子，任何语言多线程必学的例子。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 线程的同步-同步块</span><br><span class="line"> </span><br><span class="line">对于同步，除了同步方法外，还可以使用同步代码块，有时候同步代码块会带来比同步方法更好的效果。</span><br><span class="line"> </span><br><span class="line">追其同步的根本的目的，是控制竞争资源的正确的访问，因此只要在访问竞争资源的时候保证同一时刻只能一个线程访问即可，因此Java引入了同步代码快的策略，以提高性能。</span><br><span class="line"> </span><br><span class="line">在上个例子的基础上，对oper方法做了改动，由同步方法改为同步代码块模式，程序的执行逻辑并没有问题。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">```Java</span><br><span class="line">class User2 </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String code;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> cash;</span><br><span class="line"></span><br><span class="line">	User2(String code, <span class="keyword">int</span> cash) &#123;</span><br><span class="line">		<span class="keyword">this</span>.code = code;</span><br><span class="line">		<span class="keyword">this</span>.cash = cash;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.code = code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 业务方法</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> x</span><br><span class="line">	 *            添加x万元</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oper</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.cash += x;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+ <span class="string">"运行结束，增加“"</span> + x + <span class="string">"”，当前用户账户余额为："</span> + cash);</span><br><span class="line">			&#125;</span><br><span class="line">			Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"User&#123;"</span> + <span class="string">"code='"</span> + code + <span class="string">'\''</span> + <span class="string">", cash="</span> + cash + <span class="string">'&#125;'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> User2 u;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	MyThread2(String name, User2 u, <span class="keyword">int</span> y) &#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.u = u;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		u.oper(y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		User2 u = <span class="keyword">new</span> User2(<span class="string">"张三"</span>, <span class="number">100</span>);</span><br><span class="line">		MyThread2 t1 = <span class="keyword">new</span> MyThread2(<span class="string">"线程A"</span>, u, <span class="number">20</span>);</span><br><span class="line">		MyThread2 t2 = <span class="keyword">new</span> MyThread2(<span class="string">"线程B"</span>, u, -<span class="number">60</span>);</span><br><span class="line">		MyThread2 t3 = <span class="keyword">new</span> MyThread2(<span class="string">"线程C"</span>, u, -<span class="number">80</span>);</span><br><span class="line">		MyThread2 t4 = <span class="keyword">new</span> MyThread2(<span class="string">"线程D"</span>, u, -<span class="number">30</span>);</span><br><span class="line">		MyThread2 t5 = <span class="keyword">new</span> MyThread2(<span class="string">"线程E"</span>, u, <span class="number">32</span>);</span><br><span class="line">		MyThread2 t6 = <span class="keyword">new</span> MyThread2(<span class="string">"线程F"</span>, u, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">		t4.start();</span><br><span class="line">		t5.start();</span><br><span class="line">		t6.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程E运行结束，增加“32”，当前用户账户余额为：132<br>线程B运行结束，增加“-60”，当前用户账户余额为：72<br>线程D运行结束，增加“-30”，当前用户账户余额为：42<br>线程F运行结束，增加“21”，当前用户账户余额为：63<br>线程C运行结束，增加“-80”，当前用户账户余额为：-17<br>线程A运行结束，增加“20”，当前用户账户余额为：3 </p>
<p>注意：<br>在使用synchronized关键字时候，应该尽可能避免在synchronized方法或synchronized块中使用sleep或者yield方法，因为synchronized程序块占有着对象锁，你休息那么其他的线程只能一边等着你醒来执行完了才能执行。不但严重影响效率，也不合逻辑。<br>同样，在同步程序块内调用yeild方法让出CPU资源也没有意义，因为你占用着锁，其他互斥线程还是无法访问同步程序块。当然与同步程序块无关的线程可以获得更多的执行时间。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="线程的同步-同步方法">线程的同步-同步方法</h1><p>线程的同步是<span style="color:red">保证多线程安全访问竞争资源的一种手段。</span><br>线程的同步是Java多线程编程的难点，往往开发者搞不清楚什么是竞争资源、什么时候需要考虑同步，怎么同步等等问题，当然，这些问题没有很明确的答案，但有些原则问题需要考虑，是否有竞争资源被同时改动的问题？</p>
<p>在本文之前，请参阅《Java线程：线程的同步与锁》，本文是在此基础上所写的。<br>]]>
    
    </summary>
    
      <category term="Concurrency" scheme="http://jiangnan31.github.io/tags/Concurrency/"/>
    
      <category term="转载" scheme="http://jiangnan31.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java 多线程<六>]]></title>
    <link href="http://jiangnan31.github.io/2014/12/09/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%AD/"/>
    <id>http://jiangnan31.github.io/2014/12/09/java-多线程-六/</id>
    <published>2014-12-09T11:16:50.000Z</published>
    <updated>2015-09-05T03:45:34.741Z</updated>
    <content type="html"><![CDATA[<h1 id="线程的调度-优先级">线程的调度-优先级</h1><p>与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。</p>
<p>线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。</p>
<p>在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line">* Java线程：线程的调度-优先级 </span><br><span class="line">* </span><br><span class="line">* <span class="doctag">@author</span> leizhimin 2009-11-4 9:02:40 </span><br><span class="line">*/</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"线程1第"</span> + i + <span class="string">"次执行！"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"线程2第"</span> + i + <span class="string">"次执行！"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPriority</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">		t1.setPriority(<span class="number">10</span>);</span><br><span class="line">		t2.setPriority(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		t2.start();</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Result:</strong><br>线程2第0次执行！<br>线程1第0次执行！<br>线程1第1次执行！<br>线程2第1次执行！<br>线程1第2次执行！<br>线程2第2次执行！<br>线程1第3次执行！<br>线程2第3次执行！<br>线程1第4次执行！<br>线程2第4次执行！<br>线程1第5次执行！<br>线程2第5次执行！<br>线程1第6次执行！<br>线程2第6次执行！<br>线程1第7次执行！<br>线程2第7次执行！<br>线程1第8次执行！<br>线程2第8次执行！<br>线程1第9次执行！<br>线程2第9次执行！ </p>
<h1 id="线程的调度-让步">线程的调度-让步</h1><p>线程的让步含义就是使当前运行着线程让出CPU资源，但是然给谁不知道，仅仅是让出，线程状态回到可运行状态。</p>
<p>线程的让步使用Thread.yield()方法，yield() 为静态方法，功能是暂停当前正在执行的线程对象，并执行其他线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line">* Java线程：线程的调度-让步 </span><br><span class="line">* </span><br><span class="line">*/</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">                    System.out.println(<span class="string">"线程1第"</span> + i + <span class="string">"次执行！"</span>); </span><br><span class="line">            &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">                    System.out.println(<span class="string">"线程2第"</span> + i + <span class="string">"次执行！"</span>); </span><br><span class="line">                    Thread.yield(); </span><br><span class="line">            &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadYield</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">                Thread t1 = <span class="keyword">new</span> MyThread2(); </span><br><span class="line">                Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable2()); </span><br><span class="line"></span><br><span class="line">                t2.start(); </span><br><span class="line">                t1.start(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程2第0次执行！<br>线程2第1次执行！<br>线程1第0次执行！<br>线程1第1次执行！<br>线程1第2次执行！<br>线程1第3次执行！<br>线程2第2次执行！<br>线程1第4次执行！<br>线程2第3次执行！<br>线程2第4次执行！<br>线程2第5次执行！<br>线程1第5次执行！<br>线程1第6次执行！<br>线程2第6次执行！<br>线程2第7次执行！<br>线程2第8次执行！<br>线程1第7次执行！<br>线程1第8次执行！<br>线程1第9次执行！<br>线程2第9次执行！ </p>
<p><span style="color:red">yiedld这个方法是让当前线程回到可执行状态，以便让具有相同优先级的线程进入执行状态，但不是绝对的。因为虚拟机可能会让该线程重新进入执行状态。？？</span></p>
<h1 id="线程的调度-合并">线程的调度-合并</h1><p>线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是<span style="color:red">当一个线程必须等待另一个线程执行完毕才能执行时可以使用join方法。</span></p>
<p>join为非静态方法，定义如下：<br>void join()<br>    等待该线程终止。<br>void join(long millis)<br>    等待该线程终止的时间最长为 millis 毫秒。<br>void join(long millis, int nanos)<br>    等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line">* Java线程：线程的调度-合并 </span><br><span class="line">* </span><br><span class="line">* <span class="doctag">@author</span> leizhimin 2009-11-4 9:02:40 </span><br><span class="line">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">                Thread t1 = <span class="keyword">new</span> MyThread1(); </span><br><span class="line">                t1.start(); </span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123; </span><br><span class="line">                        System.out.println(<span class="string">"主线程第"</span> + i + <span class="string">"次执行！"</span>); </span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">2</span>) <span class="keyword">try</span> &#123; </span><br><span class="line">                                <span class="comment">//t1线程合并到主线程中，主线程停止执行过程，转而执行t1线程，直到t1执行完毕后继续。 </span></span><br><span class="line">                                t1.join(); </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">                        System.out.println(<span class="string">"线程1第"</span> + i + <span class="string">"次执行！"</span>); </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主线程第0次执行！<br>线程1第0次执行！<br>主线程第1次执行！<br>线程1第1次执行！<br>主线程第2次执行！<br>主线程第3次执行！<br>线程1第2次执行！<br>线程1第3次执行！<br>线程1第4次执行！<br>线程1第5次执行！<br>线程1第6次执行！<br>线程1第7次执行！<br>线程1第8次执行！<br>线程1第9次执行！<br>join结束<br>主线程第4次执行！<br>join结束<br>主线程第5次执行！<br>join结束<br>主线程第6次执行！<br>join结束<br>主线程第7次执行！<br>join结束<br>主线程第8次执行！<br>join结束<br>主线程第9次执行！<br>join结束<br>主线程第10次执行！<br>join结束<br>主线程第11次执行！<br>join结束<br>主线程第12次执行！<br>join结束<br>主线程第13次执行！<br>join结束<br>主线程第14次执行！<br>join结束<br>主线程第15次执行！<br>join结束<br>主线程第16次执行！<br>join结束<br>主线程第17次执行！<br>join结束<br>主线程第18次执行！<br>join结束<br>主线程第19次执行！<br>join结束</p>
<h1 id="线程的调度-守护线程">线程的调度-守护线程</h1><p>守护线程与普通线程写法上基本么啥区别，调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。</p>
<p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。</p>
<p>setDaemon方法的详细说明：<br>public final void setDaemon(boolean on)将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。<br>  该方法必须在启动线程前调用。</p>
<p>  该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。    </p>
<p>  参数：<br>    on - 如果为 true，则将该线程标记为守护线程。<br>  抛出：<br>    IllegalThreadStateException - 如果该线程处于活动状态。<br>    SecurityException - 如果当前线程无法修改该线程。<br>  另请参见：<br>    isDaemon(), checkAccess()<br>Thread源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Marks this thread as either a daemon thread or a user thread. The </span><br><span class="line">     * Java Virtual Machine exits when the only threads running are all </span><br><span class="line">     * daemon threads. </span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * This method must be called before the thread is started. </span><br><span class="line">      * &lt;p&gt;</span><br><span class="line">     * This method first calls the &lt;code&gt;checkAccess&lt;/code&gt; method </span><br><span class="line">     * of this thread </span><br><span class="line">     * with no arguments. This may result in throwing a </span><br><span class="line">     * &lt;code&gt;SecurityException &lt;/code&gt;(in the current thread). </span><br><span class="line">    *</span><br><span class="line">     * <span class="doctag">@param</span>      on   if &lt;code&gt;true&lt;/code&gt;, marks this thread as a</span><br><span class="line">     *                  daemon thread.</span><br><span class="line">     * <span class="doctag">@exception</span>  IllegalThreadStateException  if this thread is active.</span><br><span class="line">     * <span class="doctag">@exception</span>  SecurityException  if the current thread cannot modify</span><br><span class="line">     *               this thread.</span><br><span class="line">     * <span class="doctag">@see</span>        #isDaemon()</span><br><span class="line">     * <span class="doctag">@see</span>        #checkAccess</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;</span><br><span class="line">	checkAccess();</span><br><span class="line">	<span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">	&#125;</span><br><span class="line">	daemon = on;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line">* Java线程：线程的调度-守护线程 </span><br><span class="line">* </span><br><span class="line">* <span class="doctag">@author</span> leizhimin 2009-11-4 9:02:40 </span><br><span class="line">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">                Thread t1 = <span class="keyword">new</span> MyCommon(); </span><br><span class="line">                Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyDaemon()); </span><br><span class="line">                t2.setDaemon(<span class="keyword">true</span>);        <span class="comment">//设置为守护线程 </span></span><br><span class="line"></span><br><span class="line">                t2.start(); </span><br><span class="line">                t1.start(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCommon</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">                        System.out.println(<span class="string">"线程1第"</span> + i + <span class="string">"次执行！"</span>); </span><br><span class="line">                        <span class="keyword">try</span> &#123; </span><br><span class="line">                                Thread.sleep(<span class="number">7</span>); </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDaemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">9999999L</span>; i++) &#123; </span><br><span class="line">                        System.out.println(<span class="string">"后台线程第"</span> + i + <span class="string">"次执行！"</span>); </span><br><span class="line">                        <span class="keyword">try</span> &#123; </span><br><span class="line">                                Thread.sleep(<span class="number">7</span>); </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Result:</strong><br>后台线程第0次执行！<br>线程1第0次执行！<br>线程1第1次执行！<br>后台线程第1次执行！<br>后台线程第2次执行！<br>线程1第2次执行！<br>线程1第3次执行！<br>后台线程第3次执行！<br>线程1第4次执行！<br>后台线程第4次执行！<br>后台线程第5次执行！<br>后台线程第6次执行！<br>后台线程第7次执行！ </p>
<p>从上面的执行结果可以看出：<br>前台线程是保证执行完毕的，后台线程还没有执行完毕就退出了。</p>
<p>关于守护线程的实例：<a href="http://jiangnan31.github.io/2014/10/28/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/">http://jiangnan31.github.io/2014/10/28/Java-多线程 &lt;一&gt;/</a>    </p>
<p>实际上：JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程时候一定要注意这个问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="线程的调度-优先级">线程的调度-优先级</h1><p>与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。</p>
<p>线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。</p>
<p>在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。</p>]]>
    
    </summary>
    
      <category term="Concurrency" scheme="http://jiangnan31.github.io/tags/Concurrency/"/>
    
      <category term="转载" scheme="http://jiangnan31.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 多线程<五> 线程的交互&&线程的调度-休眠(转载)]]></title>
    <link href="http://jiangnan31.github.io/2014/12/09/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%94/"/>
    <id>http://jiangnan31.github.io/2014/12/09/Java-多线程-五/</id>
    <published>2014-12-09T06:44:19.000Z</published>
    <updated>2015-09-05T03:45:23.957Z</updated>
    <content type="html"><![CDATA[<h1 id="线程的交互">线程的交互</h1><h2 id="一、线程交互的基础知识">一、线程交互的基础知识</h2><p>线程交互知识点需要从java.lang.Object的类的三个方法来学习：</p>
<p>(1) void notify()<br>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唤醒在此对象监视器上等待的单个线程。<br>(2) void notifyAll()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唤醒在此对象监视器上等待的所有线程。<br>(3) void wait()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</p>
<a id="more"></a>
<p>当然，wait()还有另外两个重载方法：</p>
<p>(1) void wait(long timeout)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。<br>(2) void wait(long timeout, int nanos)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p>
<p>以上这些方法是帮助线程传递线程关心的时间状态。</p>
<p>关于等待/通知，要记住的关键点是：<br>必须从同步环境内调用wait()、notify()、notifyAll()方法。<span style="color:red">线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁。</span><br>wait()、notify()、notifyAll()都是Object的实例方法。与每个对象具有锁一样，每个对象可以有一个线程列表，他们等待来自该信号（通知）。线程通过执行对象上的wait()方法获得这个等待列表。从那时候起，它不再执行任何其他指令，直到调用对象的notify()方法为止。如果多个线程在同一个对象上等待，则将只选择一个线程（不保证以何种顺序）继续执行。如果没有线程等待，则不采取任何特殊操作。</p>
<p>下面看个例子就明白了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line">* 计算1+2+3 ... +100的和 </span><br><span class="line">* </span><br><span class="line">* <span class="doctag">@author</span> leizhimin 2008-9-15 13:20:49 </span><br><span class="line">*/</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> total; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123; </span><br><span class="line">                total += i; </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒 </span></span><br><span class="line">            notify(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span><br><span class="line">* 计算输出其他线程锁计算的数据 </span><br><span class="line">* </span><br><span class="line">* <span class="doctag">@author</span> leizhimin 2008-9-15 13:20:38 </span><br><span class="line">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        ThreadB b = <span class="keyword">new</span> ThreadB(); </span><br><span class="line">        <span class="comment">//启动计算线程 </span></span><br><span class="line">        b.start(); </span><br><span class="line">        <span class="comment">//线程A拥有b对象上的锁。线程为了调用wait()或notify()方法，该线程必须是那个对象锁的拥有者 </span></span><br><span class="line">        <span class="keyword">synchronized</span> (b) &#123; </span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                System.out.println(<span class="string">"等待对象b完成计算。。。"</span>); </span><br><span class="line">                <span class="comment">//当前线程A等待 </span></span><br><span class="line">                b.wait(); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(<span class="string">"b对象计算的总和是："</span> + b.total); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Result:</strong><br>等待对象b完成计算。。。<br>b对象计算的总和是：5050 </p>
<p>Process finished with exit code 0</p>
<p>个人理解，不知道对错。。。</p>
<blockquote>
<p>对象b自身具有锁，同时也存有一个线程列表，他们等待来自该信号（通知）。上述代码中的主线程通过执行对象b上的wait()方法获得这个等待列表。从那时候起，它不再执行任何其他指令，直到调用对象的notify()方法为止。</p>
</blockquote>
<p>千万注意：<br>当在对象上调用wait()方法时，执行该代码的线程立即放弃它在对象上的锁。然而<span style="color:red">调用notify()时，并不意味着这时线程会放弃其锁。</span>如果线程仍然在完成同步代码，则线程在移出之前不会放弃锁。因此，只要调用notify()并不意味着这时该锁变得可用。</p>
<p>二、多个线程在等待一个对象锁时候使用notifyAll()</p>
<p>在多数情况下，最好通知等待某个对象的所有线程。如果这样做，可以在对象上使用notifyAll()让所有在此对象上等待的线程冲出等待区，返回到可运行状态。</p>
<p>下面给个例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Calculator extends Thread &#123; </span><br><span class="line">        int total; </span><br><span class="line"></span><br><span class="line">        public void run() &#123; </span><br><span class="line">                synchronized (this) &#123; </span><br><span class="line">                        for (int i = 0; i &lt; 101; i++) &#123; </span><br><span class="line">                                total += i; </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                //通知所有在此对象上等待的线程 </span><br><span class="line">                notifyAll(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ReaderResult extends Thread &#123; </span><br><span class="line">        Calculator c; </span><br><span class="line"></span><br><span class="line">        public ReaderResult(Calculator c) &#123; </span><br><span class="line">                this.c = c; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void run() &#123; </span><br><span class="line">                synchronized (c) &#123; </span><br><span class="line">                        try &#123; </span><br><span class="line">                                System.out.println(Thread.currentThread() + "等待计算结果。。。"); </span><br><span class="line">                                c.wait(); </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                        System.out.println(Thread.currentThread() + "计算结果为：" + c.total); </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                Calculator calculator = new Calculator(); </span><br><span class="line"></span><br><span class="line">                //启动三个线程，分别获取计算结果 </span><br><span class="line">                new ReaderResult(calculator).start(); </span><br><span class="line">                new ReaderResult(calculator).start(); </span><br><span class="line">                new ReaderResult(calculator).start(); </span><br><span class="line">                //启动计算线程 </span><br><span class="line">                calculator.start(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">运行结果：</span><br><span class="line">Thread[Thread-1,5,main]等待计算结果。。。 </span><br><span class="line">Thread[Thread-2,5,main]等待计算结果。。。 </span><br><span class="line">Thread[Thread-3,5,main]等待计算结果。。。 </span><br><span class="line">Exception in thread "Thread-0" java.lang.IllegalMonitorStateException: current thread not owner </span><br><span class="line">  at java.lang.Object.notifyAll(Native Method) </span><br><span class="line">  at threadtest.Calculator.run(Calculator.java:18) </span><br><span class="line">Thread[Thread-1,5,main]计算结果为：5050 </span><br><span class="line">Thread[Thread-2,5,main]计算结果为：5050 </span><br><span class="line">Thread[Thread-3,5,main]计算结果为：5050 </span><br><span class="line"></span><br><span class="line">Process finished with exit code 0 </span><br><span class="line"> </span><br><span class="line">运行结果表明，程序中有异常，并且多次运行结果可能有多种输出结果。这就是说明，这个多线程的交互程序还存在问题。究竟是出了什么问题，需要深入的分析和思考，下面将做具体分析。</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">根据jdk的void notifyAll()的描述，“解除那些在该对象上调用</span><br><span class="line">wait()方法的线程的阻塞状态。</span><br><span class="line">该方法只能在同步方法或同步块内部调用。</span><br><span class="line">如果当前线程不是对象所得持有者，该方法抛出一个</span><br><span class="line">java.lang.IllegalMonitorStateException 异常”</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">实际上，上面这个代码中，我们期望的是读取结果的线程在计算线程调用notifyAll()之前等待即可。 但是，如果计算线程先执行，并在读取结果线程等待之前调用了notify()方法，那么又会发生什么呢？这种情况是可能发生的。因为无法保证线程的不同部分将按照什么顺序来执行。幸运的是当读取线程运行时，它只能马上进入等待状态----它没有做任何事情来检查等待的事件是否已经发生。  ----因此，如果计算线程已经调用了notifyAll()方法，那么它就不会再次调用notifyAll()，----并且等待的读取线程将永远保持等待。这当然是开发者所不愿意看到的问题。</span><br><span class="line"> </span><br><span class="line">因此，当等待的事件发生时，需要能够检查notifyAll()通知事件是否已经发生。通常，解决上面问题的最佳方式是利用某种循环，该循环检查某个条件表达式，只有当正在等待的事情还没有发生的情况下，它才继续等待。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 线程的调度-休眠</span><br><span class="line"></span><br><span class="line">Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。</span><br><span class="line"> </span><br><span class="line">这里要明确的一点，不管程序员怎么编写调度，&lt;span style= "color:red"&gt;只能最大限度的影响线程执行的次序，而不能做到精准控制。&lt;/span&gt;</span><br><span class="line"> </span><br><span class="line">线程休眠的目的是使线程让出CPU的最简单的做法之一，线程休眠时候，会将CPU资源交给其他线程，以便能轮换执行，当休眠一定时间后，线程会苏醒，进入准备状态等待执行。</span><br><span class="line"> </span><br><span class="line">线程休眠的方法是Thread.sleep(long millis) 和Thread.sleep(long millis, int nanos) ，均为静态方法，那调用sleep休眠的哪个线程呢？简单说，哪个线程调用sleep，就休眠哪个线程。</span><br><span class="line">```Java</span><br><span class="line">/** </span><br><span class="line">* Java线程：线程的调度-休眠 </span><br><span class="line">* </span><br><span class="line">* @author leizhimin 2009-11-4 9:02:40 </span><br><span class="line">*/ </span><br><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                Thread t1 = new MyThread1(); </span><br><span class="line">                Thread t2 = new Thread(new MyRunnable()); </span><br><span class="line">                t1.start(); </span><br><span class="line">                t2.start(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">class MyThread1 extends Thread &#123; </span><br><span class="line">        public void run() &#123; </span><br><span class="line">                for (int i = 0; i &lt; 3; i++) &#123; </span><br><span class="line">                        System.out.println("线程1第" + i + "次执行！"); </span><br><span class="line">                        try &#123; </span><br><span class="line">                                Thread.sleep(50); </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">class MyRunnable implements Runnable &#123; </span><br><span class="line">        public void run() &#123; </span><br><span class="line">                for (int i = 0; i &lt; 3; i++) &#123; </span><br><span class="line">                        System.out.println("线程2第" + i + "次执行！"); </span><br><span class="line">                        try &#123; </span><br><span class="line">                                Thread.sleep(50); </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程2第0次执行！<br>线程1第0次执行！<br>线程1第1次执行！<br>线程2第1次执行！<br>线程1第2次执行！<br>线程2第2次执行！ </p>
<p>从上面的结果输出可以看出，无法精准保证线程执行次序。<br>转载自：<a href="http://lavasoft.blog.51cto.com/62575/27069/" target="_blank" rel="external">http://lavasoft.blog.51cto.com/62575/27069/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="线程的交互">线程的交互</h1><h2 id="一、线程交互的基础知识">一、线程交互的基础知识</h2><p>线程交互知识点需要从java.lang.Object的类的三个方法来学习：</p>
<p>(1) void notify()<br>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唤醒在此对象监视器上等待的单个线程。<br>(2) void notifyAll()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唤醒在此对象监视器上等待的所有线程。<br>(3) void wait()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</p>]]>
    
    </summary>
    
      <category term="Concurrency" scheme="http://jiangnan31.github.io/tags/Concurrency/"/>
    
      <category term="转载" scheme="http://jiangnan31.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[function & this in JavaScript]]></title>
    <link href="http://jiangnan31.github.io/2014/12/03/function-this-in-JavaScript/"/>
    <id>http://jiangnan31.github.io/2014/12/03/function-this-in-JavaScript/</id>
    <published>2014-12-03T09:48:53.000Z</published>
    <updated>2015-09-05T03:36:13.314Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>javascript中的函数不同于其他的语言，每个函数都是作为一个对象被维护和运行的。通过函数对象的性质，可以很方便的将一个函数赋值给一个变量或者将函数作为参数传递。在继续讲述之前，先看一下函数的使用语法：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">…</span>)</span>&#123;…&#125;</span><br><span class="line"><span class="keyword">var</span> func2=<span class="function"><span class="keyword">function</span>(<span class="params">…</span>)</span>&#123;…&#125;;</span><br><span class="line"><span class="keyword">var</span> func3=<span class="function"><span class="keyword">function</span> <span class="title">func4</span>(<span class="params">…</span>)</span>&#123;…&#125;;</span><br><span class="line"><span class="keyword">var</span> func5=<span class="keyword">new</span> <span class="built_in">Function</span>();</span><br></pre></td></tr></table></figure></p>
<p>这些都是声明函数的正确语法。它们和其他语言中常见的函数或之前介绍的函数定义方式有着很大的区别。那么在JavaScript中为什么能这么写？它所遵循的语法是什么呢？下面将介绍这些内容：</p>
<a id="more"></a>
<h2 id="认识函数对象（Function_Object）">认识函数对象（Function Object）</h2><p>可以用function关键字定义一个函数，并为每个函数指定一个函数名，通过函数名来进行调用。在JavaScript解释执行时，函数都是被维护为一个对象，这就是要介绍的函数对象（Function Object）。</p>
<p><span style="color:red">函数对象与其他用户所定义的对象有着本质的区别，这一类对象被称之为内部对象</span>，例如日期对象（Date）、数组对象（Array）、字符串对象 （String）都属于内部对象。这些内置对象的构造器是由JavaScript本身所定义的：通过执行new Array()这样的语句返回一个对象，<span style="color:red">JavaScript内部有一套机制来初始化返回的对象，而不是由用户来指定对象的构造方式。</span></p>
<p>在JavaScript中，函数对象对应的类型是Function，正如数组对象对应的类型是Array，日期对象对应的类型是Date一样，可以通过 new Function()来创建一个函数对象，也可以通过function关键字来创建一个对象。为了便于理解，我们比较函数对象的创建和数组对象的创建。先 看数组对象：下面两行代码都是创建一个数组对象myArray：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray=[];</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> myArray=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure></p>
<p>同样，下面的两段代码也都是创建一个函数myFunction：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> myFunction=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"return a+b"</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过和构造数组对象语句的比较，可以清楚的看到函数对象本质，前面介绍的函数声明是上述代码的第一种方式，而<span style="color:red">在解释器内部，当遇到这种语法时，就会自动构 造一个Function对象，将函数作为一个内部的对象来存储和运行。从这里也可以看到，一个函数对象名称（函数变量）和一个普通变量名称具有同样的规 范，都可以通过变量名来引用这个变量，但是函数变量名后面可以跟上括号和参数列表来进行函数调用。</span></p>
<p>用new Function()的形式来创建一个函数不常见，因为一个函数体通常会有多条语句，如果将它们以一个字符串的形式作为参数传递，代码的可读性差。下面介绍一下其使用语法：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcName=<span class="keyword">new</span> <span class="built_in">Function</span>(p1,p2,...,pn,body);</span><br></pre></td></tr></table></figure></p>
<p>参数的类型都是字符串，p1到pn表示所创建函数的参数名称列表，body表示所创建函数的函数体语句，funcName就是所创建函数的名称。可以不指定任何参数创建一个空函数，不指定funcName创建一个无名函数，当然那样的函数没有任何意义。</p>
<p>需要注意的是，p1到pn是参数名称的列表，即p1不仅能代表一个参数，它也可以是一个逗号隔开的参数列表，例如下面的定义是等价的：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>  <span class="built_in">Function</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"return a+b+c"</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a, b, c"</span>, <span class="string">"return a+b+c"</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a,b"</span>, <span class="string">"c"</span>, <span class="string">"return a+b+c"</span>)</span><br></pre></td></tr></table></figure></p>
<p>JavaScript引入Function类型并提供new Function()这样的语法是因为函数对象添加属性和方法就必须借助于Function这个类型。</p>
<p>函数的本质是一个内部对象，由JavaScript解释器决定其运行方式。通过上述代码创建的函数，在程序中可以使用函数名进行调用。本节开头列出的函数定义问题也得到了解释。<span style="color:red">注意可直接在函数声明后面加上括号就表示创建完成后立即进行函数调用</span>，例如：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">alert(i);</span><br></pre></td></tr></table></figure></p>
<p>这段代码会显示变量i的值等于3。i是表示返回的值，而不是创建的函数，因为<span style="color:red">括号“(”比等号“=”有更高的优先级。</span>这样的代码可能并不常用，但当用户想在很长的代码段中进行模块化设计或者想避免命名冲突，这是一个不错的解决办法。</p>
<p>需要注意的是，尽管下面两种创建函数的方法是等价的：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> funcName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red">但前面一种方式创建的是有名函数，而后面是创建了一个无名函数，只是让一个变量指向了这个无名函数。在使用上仅有一点区别，就是：对于有名函数，它可以出现在调用之后再定义；而对于无名函数，它必须是在调用之前就已经定义。</span><br>例如：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"JavaScript"</span> type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="xml"><span class="comment">&lt;!--</span><br><span class="line">func();</span><br><span class="line">var func=function()&#123;</span><br><span class="line">alert(1)</span><br><span class="line">&#125;</span><br><span class="line">//--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这段语句将产生func未定义的错误，而：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"JavaScript"</span> type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="xml"><span class="comment">&lt;!--</span><br><span class="line">func();</span><br><span class="line">function func()&#123;</span><br><span class="line">alert(1)</span><br><span class="line">&#125;</span><br><span class="line">//--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>则能够正确执行，下面的语句也能正确执行：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"JavaScript"</span> type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="xml"><span class="comment">&lt;!--</span><br><span class="line">func();</span><br><span class="line">var someFunc=function func()&#123;</span><br><span class="line">alert(1)</span><br><span class="line">&#125;</span><br><span class="line">//--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p><span style="color:red">由此可见，尽管JavaScript是一门解释型的语言，但它会在函数调用时，检查整个代码中是否存在相应的函数定义，这个函数名只有是通过function funcName()形式定义的才会有效，而不能是匿名函数。</span></p>
<h2 id="函数对象和其他内部对象的关系">函数对象和其他内部对象的关系</h2><p>除了函数对象，还有很多内部对象，比如：Object、Array、Date、RegExp、Math、Error。这些名称实际上表示一个类型，可以通 过new操作符返回一个对象。然而函数对象和其他对象不同，当用typeof得到一个函数对象的类型时，它仍然会返回字符串“function”，而 typeof一个数组对象或其他的对象时，它会返回字符串“object”。</p>
<p>下面的代码示例了typeof不同类型的情况：</p>
<p>以下是引用片段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span>(<span class="built_in">Function</span>));</span><br><span class="line">alert(<span class="keyword">typeof</span>(<span class="keyword">new</span> <span class="built_in">Function</span>()));</span><br><span class="line">alert(<span class="keyword">typeof</span>(<span class="built_in">Array</span>));</span><br><span class="line">alert(<span class="keyword">typeof</span>(<span class="built_in">Object</span>));</span><br><span class="line">alert(<span class="keyword">typeof</span>(<span class="keyword">new</span> <span class="built_in">Array</span>()));</span><br><span class="line">alert(<span class="keyword">typeof</span>(<span class="keyword">new</span> <span class="built_in">Date</span>()));</span><br><span class="line">alert(<span class="keyword">typeof</span>(<span class="keyword">new</span> <span class="built_in">Object</span>()));</span><br></pre></td></tr></table></figure>
<p>运行这段代码可以发现：前面4条语句都会显示“function”，而后面3条语句则显示“object”，可见new一个function实际上是返回 一个函数。这与其他的对象有很大的不同。其他的类型Array、Object等都会通过new操作符返回一个普通对象。  (<strong>可以在控制台中进行测试</strong>)<br>尽管函数本身也是一个对象，但它与 普通的对象还是有区别的，因为它同时也是对象构造器，也就是说，可以new一个函数来返回一个对象，这在前面已经介绍。所有typeof返回 “function”的对象都是函数对象。也称这样的对象为构造器（constructor），因而，所有的构造器都是对象，但不是所有的对象都是构造 器。</p>
<p><span style="color:red">既然函数本身也是一个对象，它们的类型是function，联想到C++、Java等面向对象语言的类定义，可以猜测到Function类型的作用所在， 那就是可以给函数对象本身定义一些方法和属性，借助于函数的prototype对象，可以很方便地修改和扩充Function类型的定义。</span></p>
<p>例如下面扩展了 函数类型Function，为其增加了method1方法，作用是弹出对话框显示”function”：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.method1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"function"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line">func1.method1();</span><br><span class="line">func1.method1.method1();</span><br></pre></td></tr></table></figure></p>
<p>注意最后一个语句：func1.method1.mehotd1()，它调用了method1这个函数对象的method1方法。虽然看上去有点容易混 淆，但仔细观察一下语法还是很明确的：这是一个递归的定义。因为method1本身也是一个函数，所以它同样具有函数对象的属性和方法，所有对 Function类型的方法扩充都具有这样的递归性质。</p>
<p>Function是所有函数对象的基础，而Object则是所有对象（包括函数对象）的基础。在JavaScript中，任何一个对象都是 Object的实例，因此，可以修改Object这个类型来让所有的对象具有一些通用的属性和方法，修改Object类型是通过prototype来完成 的：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.getType=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> array1=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">alert(array1.getType());  <span class="comment">//object</span></span><br><span class="line">alert(func1.getType());   <span class="comment">//function</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码为所有的对象添加了getType方法，作用是返回该对象的类型。两条alert语句分别会显示“object”和“function”。</p>
<h2 id="将函数作为参数传递">将函数作为参数传递</h2><p><span style="color:red">在前面已经介绍了函数对象本质，每个函数都被表示为一个特殊的对象，可以方便的将其赋值给一个变量，再通过这个变量名进行函数调用。作为一个变量，它可以 以参数的形式传递给另一个函数。</span><br>这在前面介绍JavaScript事件处理机制中已经看到过这样的用法，例如下面的程序将func1作为参数传递给 func2：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">theFunc</span>)</span>&#123;</span><br><span class="line">theFunc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"ok"</span>);</span><br><span class="line">&#125;</span><br><span class="line">func1(func2);</span><br></pre></td></tr></table></figure></p>
<p>在最后一条语句中，func2作为一个对象传递给了func1的形参theFunc，再由func1内部进行theFunc的调用。<span style="color:red">事实上，将函数作为参数传递，或者是将函数赋值给其他变量是所有事件机制的基础。</span></p>
<p>例如，如果需要在页面载入时进行一些初始化工作，可以先定义一个init的初始化函数，再通过window.onload=init;语句将其绑定到页面载入完成的事件。这里的init就是一个函数对象，它可以加入window的onload事件列表。</p>
<h2 id="传递给函数的隐含参数：arguments">传递给函数的隐含参数：arguments</h2><p>当进行函数调用时，除了指定的参数外，还创建一个隐含的对象——arguments。arguments是一个类似数组但不是数组的对象，说它类似是因为 它具有数组一样的访问性质，可以用arguments[index]这样的语法取值，拥有数组长度属性length。arguments对象存储的是实际传递给函数的参数，而不局限于函数声明所定义的参数列表，例如：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    alert(a);</span><br><span class="line">    alert(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">         alert(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>代码运行时会依次显示：1，2，1，2，3。因此，在定义函数的时候，即使不指定参数列表，仍然可以通过arguments引用到所获得的参数，这给编程 带来了很大的灵活性。<span style="color:red">arguments对象的另一个属性是callee，它表示对函数对象本身的引用，这有利于实现无名函数的递归或者保证函数的封装性。</span></p>
<p>例如使用递归来计算1到n的自然数之和：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum=<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>==n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> n+sum(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(<span class="number">100</span>));</span><br></pre></td></tr></table></figure></p>
<p>其中函数内部包含了对sum自身的调用，然而对于JavaScript来说，函数名仅仅是一个变量名，在函数内部调用sum即相当于调用一个全局变量，不能很好的体现出是调用自身，所以使用arguments.callee属性会是一个较好的办法：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum=<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>==n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n+<span class="built_in">arguments</span>.callee(n-<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">alert(sum(<span class="number">100</span>));</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red">callee属性并不是arguments不同于数组对象的惟一特征</span></p>
<p>下面的代码说明了arguments不是由Array类型创建：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.p1=<span class="number">1</span>;</span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">Array</span>().p1);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">arguments</span>.p1);</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure></p>
<p>运行代码可以发现，第一个alert语句显示为1，即表示数组对象拥有属性p1，而func调用则显示为“undefined”，即p1不是arguments的属性，由此可见，<span style="color:red">arguments并不是一个数组对象。</span></p>
<h2 id="函数的apply、call方法和length属性">函数的apply、call方法和length属性</h2><p><span style="color:red">JavaScript为函数对象定义了两个方法：apply和call，它们的作用都是将函数绑定到另外一个对象上去运行</span>，两者仅在定义参数的方式有所区别：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply(thisArg,argArray);</span><br><span class="line"><span class="built_in">Function</span>.prototype.call(thisArg[,arg1[,arg2…]]);</span><br></pre></td></tr></table></figure></p>
<p>从函数原型可以看到，<span style="color:red">第一个参数都被取名为thisArg，即所有函数内部的this指针都会被赋值为thisArg，这就实现了将函数作为另外一个对象 的方法运行的目的。两个方法除了thisArg参数，都是为Function对象传递的参数。</span></p>
<p>下面的代码说明了apply和call方法的工作方式：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个函数func1，具有属性p和方法A</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.p=<span class="string">"func1-"</span>;</span><br><span class="line">    <span class="keyword">this</span>.A=<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"A: "</span>+<span class="keyword">this</span>.p+arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个函数func2，具有属性p和方法B</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.p=<span class="string">"func2-"</span>;</span><br><span class="line">    <span class="keyword">this</span>.B=<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"B: "</span>+<span class="keyword">this</span>.p+arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function.prototype.apply(thisArg,argArray);</span></span><br><span class="line"><span class="comment">//Function.prototype.call(thisArg[,arg1[,arg2…]]); </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1=<span class="keyword">new</span> func1();</span><br><span class="line"><span class="keyword">var</span> obj2=<span class="keyword">new</span> func2();</span><br><span class="line">obj1.A(<span class="string">"byA"</span>);    <span class="comment">//显示 A: func1-byA</span></span><br><span class="line">obj2.B(<span class="string">"byB"</span>);    <span class="comment">//显示 B: func2-byB</span></span><br><span class="line">obj1.A.apply(obj2,[<span class="string">"byA"</span>]); <span class="comment">//显示 A: func2-byA，其中[“byA”]是仅有一个元素的数组，下同</span></span><br><span class="line">obj2.B.apply(obj1,[<span class="string">"byB"</span>]); <span class="comment">//显示 B: func1-byB</span></span><br><span class="line">obj1.A.call(obj2,<span class="string">"byA"</span>);  <span class="comment">//显示   A: func2-byA</span></span><br><span class="line">obj2.B.call(obj1,<span class="string">"byB"</span>);  <span class="comment">//显示   B: func1-byB</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出，obj1的方法A被绑定到obj2运行后，整个函数A的运行环境就转移到了obj2，即this指针指向了obj2。同样obj2的函数B也可以绑定到obj1对象去运行。代码的最后4行显示了apply和call函数参数形式的区别。</p>
<p><span style="color:red">与arguments的length属性不同，函数对象还有一个属性length，它表示函数定义时所指定参数的个数，而非调用时实际传递的参数个数。</span></p>
<p>例如下面的代码将显示2：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum.length);</span><br></pre></td></tr></table></figure></p>
<h2 id="深入认识JavaScript中的this指针">深入认识JavaScript中的this指针</h2><p>this指针是面向对象程序设计中的一项重要概念，它表示当前运行的对象。在实现对象的方法时，可以使用this指针来获得该对象自身的引用。</p>
<p><span style="color:red">和其他面向对象的语言不同，JavaScript中的this指针是一个动态的变量，一个方法内的this指针并不是始终指向定义该方法的对象的</span>，在上一节讲函数的apply和call方法时已经有过这样的例子。<br>为了方便理解，再来看下面的例子：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"JavaScript"</span> type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="xml"><span class="comment">&lt;!--</span><br><span class="line">//创建两个空对象</span><br><span class="line">var obj1=new Object();</span><br><span class="line">var obj2=new Object();</span><br><span class="line">//给两个对象都添加属性p，并分别等于1和2</span><br><span class="line">obj1.p=1;</span><br><span class="line">obj2.p=2;</span><br><span class="line">//给obj1添加方法，用于显示p的值</span><br><span class="line">obj1.getP=function()&#123;</span><br><span class="line">alert(this.p); //表面上this指针指向的是obj1</span><br><span class="line">&#125;</span><br><span class="line">//调用obj1的getP方法</span><br><span class="line">obj1.getP();</span><br><span class="line">//使obj2的getP方法等于obj1的getP方法</span><br><span class="line">obj2.getP=obj1.getP;</span><br><span class="line">//调用obj2的getP方法</span><br><span class="line">obj2.getP();</span><br><span class="line">//--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>从代码的执行结果看，分别弹出对话框显示1和2。由此可见，getP函数仅定义了一次，在不同的场合运行，显示了不同的运行结果，这是有this指针的变 化所决定的。在obj1的getP方法中，this就指向了obj1对象，而在obj2的getP方法中，this就指向了obj2对象，并通过 this指针引用到了两个对象都具有的属性p。</p>
<p>由此可见，JavaScript中的this指针是一个动态变化的变量，它表明了当前运行该函数的对象。由this指针的性质，也可以更好的理解 JavaScript中对象的本质：<span style="color:red">一个对象就是由一个或多个属性（方法）组成的集合。每个集合元素不是仅能属于一个集合，而是可以动态的属于多个集合。 这样，一个方法（集合元素）由谁调用，this指针就指向谁。实际上，前面介绍的apply方法和call方法都是通过强制改变this指针的值来实现 的，使this指针指向参数所指定的对象，从而达到将一个对象的方法作为另一个对象的方法运行。</span></p>
<p>每个对象集合的元素（即属性或方法）也是一个独立的部分，全局函数和作为一个对象方法定义的函数之间没有任何区别，因为可以把全局函数和变量看作为 window对象的方法和属性。也可以使用new操作符来操作一个对象的方法来返回一个对象，这样一个对象的方法也就可以定义为类的形式，其中的this 指针则会指向新创建的对象。在后面可以看到，这时对象名可以起到一个命名空间的作用，这是使用JavaScript进行面向对象程序设计的一个技巧。例 如：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> namespace1=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">namespace1.class1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//初始化对象的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=<span class="keyword">new</span> namespace1.class1();</span><br></pre></td></tr></table></figure></p>
<p>这里就可以把namespace1看成一个命名空间。</p>
<p>由于对象属性（方法）的动态变化特性，一个对象的两个属性（方法）之间的互相引用，必须要通过this指针，而其他语言中，this关键字是可以省略的。<br>如上面的例子中：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1.getP=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.p); <span class="comment">//表面上this指针指向的是obj1</span></span><br></pre></td></tr></table></figure></p>
<p>转载自：<a href="http://www.cnblogs.com/yuzhongwusan/archive/2012/04/09/2438569.html" target="_blank" rel="external">http://www.cnblogs.com/yuzhongwusan/archive/2012/04/09/2438569.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2><p>javascript中的函数不同于其他的语言，每个函数都是作为一个对象被维护和运行的。通过函数对象的性质，可以很方便的将一个函数赋值给一个变量或者将函数作为参数传递。在继续讲述之前，先看一下函数的使用语法：</p>
<p>以下是引用片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">…</span>)</span>&#123;…&#125;</span><br><span class="line"><span class="keyword">var</span> func2=<span class="function"><span class="keyword">function</span>(<span class="params">…</span>)</span>&#123;…&#125;;</span><br><span class="line"><span class="keyword">var</span> func3=<span class="function"><span class="keyword">function</span> <span class="title">func4</span>(<span class="params">…</span>)</span>&#123;…&#125;;</span><br><span class="line"><span class="keyword">var</span> func5=<span class="keyword">new</span> <span class="built_in">Function</span>();</span><br></pre></td></tr></table></figure></p>
<p>这些都是声明函数的正确语法。它们和其他语言中常见的函数或之前介绍的函数定义方式有着很大的区别。那么在JavaScript中为什么能这么写？它所遵循的语法是什么呢？下面将介绍这些内容：</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jiangnan31.github.io/tags/JavaScript/"/>
    
      <category term="转载" scheme="http://jiangnan31.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单点Hadoop搭建过程中错误]]></title>
    <link href="http://jiangnan31.github.io/2014/11/05/%E5%8D%95%E7%82%B9Hadoop%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%94%99%E8%AF%AF/"/>
    <id>http://jiangnan31.github.io/2014/11/05/单点Hadoop搭建过程中错误/</id>
    <published>2014-11-05T07:49:29.000Z</published>
    <updated>2015-09-05T03:44:40.556Z</updated>
    <content type="html"><![CDATA[<p>Hadoop 安装过程中问题 </p>
<h2 id="A_fatal_error_has_been_detected_by_the_Java_Runtime_Environment:">A fatal error has been detected by the Java Runtime Environment:</h2><p>参考: <a href="http://blog.163.com/wf_shunqiziran/blog/static/17630720920125286153575/" target="_blank" rel="external">http://blog.163.com/wf_shunqiziran/blog/static/17630720920125286153575/</a>中的方法二</p>
<a id="more"></a>
<h2 id="java-io-IOException:_File_/user/root/input_could_only_be_replicated_to_0_nodes,_instead_of_1">java.io.IOException: File /user/root/input could only be replicated to 0 nodes, instead of 1</h2><p>参考: <a href="http://www.linuxidc.com/Linux/2012-03/56220.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-03/56220.htm</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com hadoop-1.2.1]$ bin/stop-all.sh&#10;Warning: $HADOOP_HOME is deprecated.&#10;&#10;stopping jobtracker&#10;jiangnan04@localhost&#39;s password: &#10;localhost: stopping tasktracker&#10;stopping namenode&#10;jiangnan04@localhost&#39;s password: &#10;localhost: no datanode to stop&#10;jiangnan04@localhost&#39;s password: &#10;localhost: stopping secondarynamenode&#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com hadoop-1.2.1]$ bin/start-all.sh&#10;Warning: $HADOOP_HOME is deprecated.&#10;&#10;starting namenode, logging to /home/users/jiangnan04/tools/hadoop-1.2.1/libexec/../logs/hadoop-jiangnan04-namenode-cp01-rdqa-dev361.cp01.baidu.com.out&#10;jiangnan04@localhost&#39;s password: &#10;localhost: starting datanode, logging to /home/users/jiangnan04/tools/hadoop-1.2.1/libexec/../logs/hadoop-jiangnan04-datanode-cp01-rdqa-dev361.cp01.baidu.com.out&#10;jiangnan04@localhost&#39;s password: &#10;localhost: starting secondarynamenode, logging to /home/users/jiangnan04/tools/hadoop-1.2.1/libexec/../logs/hadoop-jiangnan04-secondarynamenode-cp01-rdqa-dev361.cp01.baidu.com.out&#10;starting jobtracker, logging to /home/users/jiangnan04/tools/hadoop-1.2.1/libexec/../logs/hadoop-jiangnan04-jobtracker-cp01-rdqa-dev361.cp01.baidu.com.out&#10;jiangnan04@localhost&#39;s password: &#10;localhost: starting tasktracker, logging to /home/users/jiangnan04/tools/hadoop-1.2.1/libexec/../logs/hadoop-jiangnan04-tasktracker-cp01-rdqa-dev361.cp01.baidu.com.out&#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com hadoop-1.2.1]$ bin/hadoop fs -put conf input&#10;Warning: $HADOOP_HOME is deprecated.&#10;&#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com hadoop-1.2.1]$ bin/hadoop jar hadoop-examples-*.jar grep input output &#39;dfs[a-z.]+&#39;&#10;Warning: $HADOOP_HOME is deprecated.&#10;&#10;14/11/05 16:42:23 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable&#10;14/11/05 16:42:23 WARN snappy.LoadSnappy: Snappy native library not loaded&#10;14/11/05 16:42:23 INFO mapred.FileInputFormat: Total input paths to process : 21&#10;14/11/05 16:42:24 INFO mapred.JobClient: Running job: job_201411051640_0001&#10;14/11/05 16:42:25 INFO mapred.JobClient:  map 0% reduce 0%&#10;14/11/05 16:42:30 INFO mapred.JobClient:  map 9% reduce 0%&#10;14/11/05 16:42:32 INFO mapred.JobClient:  map 19% reduce 0%&#10;14/11/05 16:42:33 INFO mapred.JobClient:  map 28% reduce 0%&#10;14/11/05 16:42:35 INFO mapred.JobClient:  map 38% reduce 0%&#10;14/11/05 16:42:37 INFO mapred.JobClient:  map 47% reduce 12%&#10;14/11/05 16:42:39 INFO mapred.JobClient:  map 57% reduce 12%&#10;14/11/05 16:42:41 INFO mapred.JobClient:  map 66% reduce 12%&#10;14/11/05 16:42:42 INFO mapred.JobClient:  map 76% reduce 12%&#10;14/11/05 16:42:44 INFO mapred.JobClient:  map 85% reduce 12%&#10;14/11/05 16:42:46 INFO mapred.JobClient:  map 95% reduce 22%&#10;14/11/05 16:42:48 INFO mapred.JobClient:  map 100% reduce 22%&#10;14/11/05 16:42:52 INFO mapred.JobClient:  map 100% reduce 33%&#10;14/11/05 16:42:54 INFO mapred.JobClient:  map 100% reduce 100%&#10;14/11/05 16:42:54 INFO mapred.JobClient: Job complete: job_201411051640_0001&#10;14/11/05 16:42:54 INFO mapred.JobClient: Counters: 30&#10;14/11/05 16:42:54 INFO mapred.JobClient:   Job Counters &#10;14/11/05 16:42:54 INFO mapred.JobClient:     Launched reduce tasks=1&#10;14/11/05 16:42:54 INFO mapred.JobClient:     SLOTS_MILLIS_MAPS=36382&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Total time spent by all reduces waiting after reserving slots (ms)=0&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Total time spent by all maps waiting after reserving slots (ms)=0&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Launched map tasks=21&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Data-local map tasks=21&#10;14/11/05 16:42:54 INFO mapred.JobClient:     SLOTS_MILLIS_REDUCES=23896&#10;14/11/05 16:42:54 INFO mapred.JobClient:   File Input Format Counters &#10;14/11/05 16:42:54 INFO mapred.JobClient:     Bytes Read=37815&#10;14/11/05 16:42:54 INFO mapred.JobClient:   File Output Format Counters &#10;14/11/05 16:42:54 INFO mapred.JobClient:     Bytes Written=180&#10;14/11/05 16:42:54 INFO mapred.JobClient:   FileSystemCounters&#10;14/11/05 16:42:54 INFO mapred.JobClient:     FILE_BYTES_READ=82&#10;14/11/05 16:42:54 INFO mapred.JobClient:     HDFS_BYTES_READ=40197&#10;14/11/05 16:42:54 INFO mapred.JobClient:     FILE_BYTES_WRITTEN=1305144&#10;14/11/05 16:42:54 INFO mapred.JobClient:     HDFS_BYTES_WRITTEN=180&#10;14/11/05 16:42:54 INFO mapred.JobClient:   Map-Reduce Framework&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Map output materialized bytes=202&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Map input records=1061&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Reduce shuffle bytes=202&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Spilled Records=6&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Map output bytes=70&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Total committed heap usage (bytes)=4421976064&#10;14/11/05 16:42:54 INFO mapred.JobClient:     CPU time spent (ms)=10760&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Map input bytes=37815&#10;14/11/05 16:42:54 INFO mapred.JobClient:     SPLIT_RAW_BYTES=2382&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Combine input records=3&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Reduce input records=3&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Reduce input groups=3&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Combine output records=3&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Physical memory (bytes) snapshot=4446228480&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Reduce output records=3&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Virtual memory (bytes) snapshot=11182075904&#10;14/11/05 16:42:54 INFO mapred.JobClient:     Map output records=3&#10;14/11/05 16:42:54 INFO mapred.FileInputFormat: Total input paths to process : 1&#10;14/11/05 16:42:54 INFO mapred.JobClient: Running job: job_201411051640_0002&#10;14/11/05 16:42:55 INFO mapred.JobClient:  map 0% reduce 0%&#10;14/11/05 16:42:59 INFO mapred.JobClient:  map 100% reduce 0%&#10;14/11/05 16:43:07 INFO mapred.JobClient:  map 100% reduce 33%&#10;14/11/05 16:43:08 INFO mapred.JobClient:  map 100% reduce 100%&#10;14/11/05 16:43:09 INFO mapred.JobClient: Job complete: job_201411051640_0002&#10;14/11/05 16:43:09 INFO mapred.JobClient: Counters: 30&#10;14/11/05 16:43:09 INFO mapred.JobClient:   Job Counters &#10;14/11/05 16:43:09 INFO mapred.JobClient:     Launched reduce tasks=1&#10;14/11/05 16:43:09 INFO mapred.JobClient:     SLOTS_MILLIS_MAPS=4483&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Total time spent by all reduces waiting after reserving slots (ms)=0&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Total time spent by all maps waiting after reserving slots (ms)=0&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Launched map tasks=1&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Data-local map tasks=1&#10;14/11/05 16:43:09 INFO mapred.JobClient:     SLOTS_MILLIS_REDUCES=8602&#10;14/11/05 16:43:09 INFO mapred.JobClient:   File Input Format Counters &#10;14/11/05 16:43:09 INFO mapred.JobClient:     Bytes Read=180&#10;14/11/05 16:43:09 INFO mapred.JobClient:   File Output Format Counters &#10;14/11/05 16:43:09 INFO mapred.JobClient:     Bytes Written=52&#10;14/11/05 16:43:09 INFO mapred.JobClient:   FileSystemCounters&#10;14/11/05 16:43:09 INFO mapred.JobClient:     FILE_BYTES_READ=82&#10;14/11/05 16:43:09 INFO mapred.JobClient:     HDFS_BYTES_READ=301&#10;14/11/05 16:43:09 INFO mapred.JobClient:     FILE_BYTES_WRITTEN=116951&#10;14/11/05 16:43:09 INFO mapred.JobClient:     HDFS_BYTES_WRITTEN=52&#10;14/11/05 16:43:09 INFO mapred.JobClient:   Map-Reduce Framework&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Map output materialized bytes=82&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Map input records=3&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Reduce shuffle bytes=82&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Spilled Records=6&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Map output bytes=70&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Total committed heap usage (bytes)=401997824&#10;14/11/05 16:43:09 INFO mapred.JobClient:     CPU time spent (ms)=1750&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Map input bytes=94&#10;14/11/05 16:43:09 INFO mapred.JobClient:     SPLIT_RAW_BYTES=121&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Combine input records=0&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Reduce input records=3&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Reduce input groups=1&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Combine output records=0&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Physical memory (bytes) snapshot=325132288&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Reduce output records=3&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Virtual memory (bytes) snapshot=1023143936&#10;14/11/05 16:43:09 INFO mapred.JobClient:     Map output records=3&#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com hadoop-1.2.1]$ bin/hadoop fs -get output output&#10;Warning: $HADOOP_HOME is deprecated.&#10;&#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com hadoop-1.2.1]$ cat output/*&#10;cat: output/_logs: Is a directory&#10;1&#9;dfs.replication&#10;1&#9;dfs.server.namenode.&#10;1&#9;dfsadmin</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>Hadoop 安装过程中问题 </p>
<h2 id="A_fatal_error_has_been_detected_by_the_Java_Runtime_Environment:">A fatal error has been detected by the Java Runtime Environment:</h2><p>参考: <a href="http://blog.163.com/wf_shunqiziran/blog/static/17630720920125286153575/">http://blog.163.com/wf_shunqiziran/blog/static/17630720920125286153575/</a>中的方法二</p>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://jiangnan31.github.io/tags/Hadoop/"/>
    
      <category term="笔记" scheme="http://jiangnan31.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[grep及正则表达式]]></title>
    <link href="http://jiangnan31.github.io/2014/11/05/grep%E5%8F%8A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://jiangnan31.github.io/2014/11/05/grep及正则表达式/</id>
    <published>2014-11-05T02:11:26.000Z</published>
    <updated>2015-09-05T04:38:51.653Z</updated>
    <content type="html"><![CDATA[<p>首先要记住的是: 正则表达式与通配符不一样,它们表示的含义并不相同!<br>正则表达式只是一种表示法,只要工具支持这种表示法， 那么该工具就可以处理正则表达式的字符串。vim、grep、awk 、sed 都支持正则表达式，也正是因为由于它们支持正则，才显得它们强大；</p>
<h2 id="1-_基础正则表达式">1. 基础正则表达式</h2><a id="more"></a>
<p>grep -[acinv] ‘搜索内容串’ filename<br>-a 以文本文件方式搜索<br>-c 计算找到的符合行的次数<br>-i 忽略大小写<br>-n 顺便输出行号<br>-v 反向选择，即找 没有搜索字符串的行<br>其中搜索串可以是正则表达式! </p>
<h3 id="1-1_搜索关键字">1.1 搜索关键字</h3><p>搜索有the的行,并输出行号<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;the&#39; crm-web.log&#10;5:11/04 10:53:15 [scheduleFactory_Worker-9] INFO  utils.BNSUtils   .getUsedJobTrackerInfo:237 - the used jobtracker is &#123;&#34;serviceName&#34;:&#34;melody-cal-bnsMonitor.MP3.91fzcm&#34;,&#34;hostName&#34;:&#34;yf-mp3-melody-cal00.yf01&#34;,&#34;port&#34;:27017,&#34;isUsed&#34;:1&#125;&#10;49:11/04 10:54:15 [scheduleFactory_Worker-9] INFO  utils.BNSUtils   .getUsedJobTrackerInfo:237 - the used jobtracker is &#123;&#34;serviceName&#34;:&#34;melody-cal-bnsMonitor.MP3.91fzcm&#34;,&#34;hostName&#34;:&#34;yf-mp3-melody-cal00.yf01&#34;,&#34;port&#34;:27017,&#34;isUsed&#34;:1&#125;</span><br></pre></td></tr></table></figure></p>
<p>搜 索没有the的行,并输出行号 (-v反选)<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep -nv &#39;the&#39; crm-web.log</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2_利_用[]搜索集合字符">1.2 利 用[]搜索集合字符</h3><p>[] 表示其中的某一个字符 ，例如[ade] 表示a或d或e<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;bi[gt]log&#39; crm-web.log&#10;&#10;75:  11/04 10:54:21 [timing-1] INFO  service.OpenDataSourceService.run:349 - [biglog] datasource has no change&#10;76:  11/04 10:54:21 [timing-1] INFO  service.OpenDataSourceService.run:349 - [bitlog] datasource has no change</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red">可以用^符号做[]内的前缀，表示除[]内的字符之外的字符。</span><br>比如搜索oo前没有g的字符串所在的行. 使用 ‘[^g]oo’ 作搜索字符串<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;[^g]oo&#39; crm-web.log&#10;41:  http://bns.noah.baidu.com/webfoot/index.php?r=Group/GroupInfo_v2&#38;groupName=group.cal-melody.MP3.ai&#10;78:  apple is my favorite food&#10;79:  Football is not use feet only&#10;80:  google is the best tools for search keyword&#10;81:  goooooog test.</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red">[] 内可以用范围表示</span>，比如[a-z] 表示小写字母,[0-9] 表示0~9的数字, [A-Z] 则是大写字母们。[a-zA-Z0-9]表示所有数字与英文字符。 当然也可以配合^来排除字符。<br>搜索包含数字的行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;[7-9]&#39; crm-web.log</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red">行首与行尾字符 ‘^’ \$</span></p>
<p>^表示行的开头，\$表示行的结尾( 不是字符，是位置）那么‘^$’ 就表示空行,因为只有<br>行首和行尾。<br>这里^与[]里面使用的^意义不同。它表示^后面的串是在行的开头。<br>比如搜索  app在开头的行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;^$&#39; crm-web.log &#10;77:&#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;^  app&#39; crm-web.log &#10;78:  apple is my favorite food</span><br></pre></td></tr></table></figure></p>
<p>搜索以小写字母开头的行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;^[a-z]&#39; crm-web.log&#10;78:apple is my favorite food&#10;79:Xmeadgsadg&#10;80:Football is not use feet only&#10;81:google is the best tools for search keywords &#10;82:goooooog test.</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red">不知道为什么会有79和80行。。。</span></p>
<p>搜索开头不是数字的行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;^[^0-9]&#39; crm-web.log&#10;52:current info:yf-mp3-melody-cal00.yf01:27017&#10;53:BNS info:yf-mp3-melody-cal00.yf01:27017&#10;76:apple is my favorite food&#10;77:Xmeadgsadg&#10;78:Football is not use feet only&#10;79:google is the best tools for search keywords &#10;80:goooooog test.</span><br></pre></td></tr></table></figure></p>
<p>$表示它前面的串是在行的结尾，比如 ‘\.’ 表示 . 在一行的结尾<br>搜索末尾是.的行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;\.$&#39; crm-web.log //.</span><br></pre></td></tr></table></figure></p>
<p>是正则表达式的特殊符号，所以要用\转义<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;\.$&#39; crm-web.log //.&#10;crm-web.log:78:Football is not use feet only.&#10;crm-web.log:80:goooooog test.</span><br></pre></td></tr></table></figure></p>
<p>注意在MS的系统下生成的文本文件，换行会加上一个 ^M 字符。所以最后的字符会是隐藏的^M ,在处理Windows<br>下面的文本时要特别注意！<br>可以用cat dos_file | tr -d ‘\r’ &gt; unix_file 来删除^M符号。 ^M==\r </p>
<p>那么’^$’ 就表示只有行首行尾的空行拉！ </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#25628;&#32034;&#31354;&#34892; &#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$  grep -n &#39;^$&#39; crm-web.log&#10;75:&#10;#&#25628;&#32034;&#38750;&#31354;&#34892; &#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$  grep -vn &#39;^$&#39; crm-web.log&#10;....</span><br></pre></td></tr></table></figure>
<p><span style="color:red">任意一个字符. 与重复字符 * </span></p>
<p><span style="color:red">在bash中<em>代表通配符，用来代表任意个 字符，但是在正则表达式中，他含义不同，</em>表示有0个或多个 某个字符。<br>例如 oo*, 表示第一个o一定存在，第二个o可以有一个或多个，也可以没有，因此代表至少一个o. </span></p>
<p>点. 代表一个任意字符，必须存在。 g??d 可以用 ‘g..d’ 表示。 good ,gxxd ,gabd …..都符合。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;bi..og&#39; crm-web.log&#10;73:11/04 10:54:21 [timing-1] INFO  service.OpenDataSourceService.run:349 - [biglog] datasource has no change&#10;74:11/04 10:54:21 [timing-1] INFO  service.OpenDataSourceService.run:349 - [bitlog] datasource has no change</span><br></pre></td></tr></table></figure>
<p>搜索两个o以上的字符串 (//前两个o一定存在，第三个o可没有，也可有多个。 )<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;ooo*&#39; crm-web.log&#10;39:http://bns.noah.baidu.com/webfoot/index.php?r=Group/GroupInfo_v2&#38;groupName=group.cal-melody.MP3.ai&#10;76:apple is my favorite food&#10;78:Football is not use feet only.&#10;79:google is the best tools for search keywords.&#10;80:goooooog test.&#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;oooo*&#39; crm-web.log&#10;80:goooooog test.</span><br></pre></td></tr></table></figure></p>
<p>搜索g开头和结尾，中间是至少一个o的字符串，即gog, goog….gooog…等<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;goo*g&#39; crm-web.log&#10;79:google is the best tools for search keywords.&#10;80:goooooog test.</span><br></pre></td></tr></table></figure></p>
<p>搜索g开头和结尾的字符串在的行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;g.*t&#39; crm-web.log   &#10; // .*&#34920;&#31034; 0&#20010;&#25110;&#22810;&#20010;&#20219;&#24847;&#23383;&#31526; &#10;1:&#34;Open Source&#34; is a good mechanism to develop programs. &#10;14:The gd software is a library for drafting programs. &#10;18:google is the best tools for search keyword. &#10;19:goooooogle yes! &#10;20:go! go! Let&#39;s go.</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red">限定连续重复字符的范围 { }  </span></p>
<p>. * 只能限制0个或多个， 如果要确切的限制字符重复数量，就用{范围} 。范围是数字用,隔开 2,5 表示2~5个,<br>2表示2个，2, 表示2到更多个<br>注意，由于{ }在SHELL中有特殊意义，因此作为正则表达式用的时候要用\转义一下。 </p>
<p>搜索包含两个o的字符串的行。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;o\&#123;2\&#125;&#39; crm-web.log&#10;39:http://bns.noah.baidu.com/webfoot/index.php?r=Group/GroupInfo_v2&#38;groupName=group.cal-melody.MP3.ai&#10;76:apple is my favorite food&#10;78:Football is not use feet only.&#10;79:google is the best tools for search keywords.&#10;80:goooooog test.&#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;o\&#123;3\&#125;&#39; crm-web.log&#10;80:goooooog test.</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#25628;&#32034;g&#21518;&#38754;&#36319;2~5&#20010;o,&#21518;&#38754;&#20877;&#36319;&#19968;&#20010;g&#30340;&#23383;&#31526;&#20018;&#30340;&#34892;&#12290;&#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;go\&#123;2,5\&#125;g&#39; crm-web.log&#10;79:google is the best tools for search keywords.&#10;#&#25628;&#32034;&#21253;&#21547;g&#21518;&#38754;&#36319;2&#20010;&#20197;&#19978;o,&#21518;&#38754;&#20877;&#36319;g&#30340;&#34892;&#12290;&#12290; &#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -n &#39;go\&#123;2,\&#125;g&#39; crm-web.log&#10;79:google is the best tools for search keywords.&#10;80:goooooog test.</span><br></pre></td></tr></table></figure>
<p>注意，相让[]中的^ － 不表现特殊意义，可以放在[]里面内容的后面。<br>‘[^a-z.!^ -]’ 表示没有小写字母，没有. 没有!, 没有空格，没有- 的 串，注意[]里面有个小空格。 </p>
<p>另外shell 里面的反向选择为[!range], 正则里面是 [^range] <span style="color:red">?</span></p>
<h2 id="2-_扩展正则表达式">2. 扩展正则表达式</h2><p>扩展正则表达式是对基础正则表达式添加了几个特殊构成的。<br>它令某些操作更加方便。<br>比如我们要去除 空白行和行首为数字的行， 会这样用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -v &#39;^$&#39; crm-web.log  | grep -v &#39;^[0-9]&#39;&#10;&#123;&#34;flag&#34;:1,&#34;jobtracker&#34;:[&#123;&#34;serviceName&#34;:&#34;crm-cal-bnsSinglePointMonitor.MP3.91fzcm&#34;,&#34;hostName&#34;:&#34;tc-mp3-melody-web01.tc&#34;,&#34;port&#34;:27017,&#34;isUsed&#34;:0&#125;,&#123;&#34;serviceName&#34;:&#34;melody-cal-bnsMonitor.MP3.91fzcm&#34;,&#34;hostName&#34;:&#34;yf-mp3-melody-cal00.yf01&#34;,&#34;port&#34;:27017,&#34;isUsed&#34;:1&#125;]&#125;&#10;current info:yf-mp3-melody-cal00.yf01:27017&#10;BNS info:yf-mp3-melody-cal00.yf01:27017&#10;apple is my favorite food&#10;Xmeadgsadg&#10;Football is not use feet only.&#10;google is the best tools for search keywords.&#10;goooooog test.&#10;# &#31649;&#36947;&#32487;&#32493;&#36807;&#28388;&#10;[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ grep -v &#39;^$&#39; crm-web.log  | grep -v &#39;^[0-9]&#39; | grep -n &#39;^[a-z]&#39;&#10;2:http://bns.noah.baidu.com/webfoot/index.php?r=Group/GroupInfo_v2&#38;groupName=group.cal-melody.MP3.ai&#10;6:current info:yf-mp3-melody-cal00.yf01:27017&#10;7:BNS info:yf-mp3-melody-cal00.yf01:27017&#10;8:apple is my favorite food&#10;9:Xmeadgsadg&#10;10:Football is not use feet only.&#10;11:google is the best tools for search keywords.&#10;12:goooooog test.</span><br></pre></td></tr></table></figure></p>
<p>然而使用支持扩展正则表达式的 egrep 与扩展特殊符号 | ，会方便许多。<br>注意grep只支持基础表达式， 而egrep 支持扩展的， 其实 egrep 是 grep -E 的别名而已。因此grep -E 支持扩展正则。<br>那么:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jiangnan04@cp01-rdqa-dev361.cp01.baidu.com document]$ egrep -v &#39;^$|^[0-9]|^&#123;&#39; crm-web.log  &#10;http://bns.noah.baidu.com/webfoot/index.php?r=Group/GroupInfo_v2&#38;groupName=group.cal-melody.MP3.ai&#10;current info:yf-mp3-melody-cal00.yf01:27017&#10;BNS info:yf-mp3-melody-cal00.yf01:27017&#10;apple is my favorite food&#10;Xmeadgsadg&#10;Football is not use feet only.&#10;google is the best tools for search keywords.&#10;goooooog test.</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red">这里| 表示或的关系。 即满足 ^$ 、 ^# 或者 ^{ 的字符串。 </span></p>
<p>这里列出几个扩展特殊符号：<br>＋， 于 . <em> 作用类似，表示 一个或多个重复字符。<br>?， 于 . </em> 作用类似，表示0个或一个字符。<br>｜，表示或关系，比如 ‘gd|good|dog’ 表示有gd,good或dog的串<br>（），将部分内容合成一个单元组。 比如 要搜索 glad 或 good 可以这样 ‘g(la|oo)d’<br><span style="color:red">()的好处是可以对小组使用 + ? * 等。 </span><br>比如要搜索A和C开头结尾，中间有至少一个(xyz) 的串，可以这样 : ‘A(xyz)+C’</p>
<p>转载自：<a href="http://www.jb51.net/article/31207.htm" target="_blank" rel="external">http://www.jb51.net/article/31207.htm</a><br>参考：<a href="http://www.jb51.net/tools/zhengze.html" target="_blank" rel="external">http://www.jb51.net/tools/zhengze.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先要记住的是: 正则表达式与通配符不一样,它们表示的含义并不相同!<br>正则表达式只是一种表示法,只要工具支持这种表示法， 那么该工具就可以处理正则表达式的字符串。vim、grep、awk 、sed 都支持正则表达式，也正是因为由于它们支持正则，才显得它们强大；</p>
<h2 id="1-_基础正则表达式">1. 基础正则表达式</h2>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://jiangnan31.github.io/tags/Linux/"/>
    
      <category term="Regex" scheme="http://jiangnan31.github.io/tags/Regex/"/>
    
      <category term="转载" scheme="http://jiangnan31.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[服务器搭建参考]]></title>
    <link href="http://jiangnan31.github.io/2014/11/03/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%8F%82%E8%80%83/"/>
    <id>http://jiangnan31.github.io/2014/11/03/服务器搭建参考/</id>
    <published>2014-11-03T08:31:25.000Z</published>
    <updated>2015-09-05T03:44:18.577Z</updated>
    <content type="html"><![CDATA[<p>阿里云的服务器被入侵，系统卡死。重新搭建服务器，为了防止再出问题记录一下：</p>
<p>JDK安装：<a href="http://www.linuxidc.com/Linux/2014-03/98320.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2014-03/98320.htm</a><br>Mysql安装：(1)<a href="http://www.linuxidc.com/Linux/2013-01/78716p3.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2013-01/78716p3.htm</a><br> (2) <a href="http://blog.csdn.net/jiangnan_java/article/details/39255349" target="_blank" rel="external">http://blog.csdn.net/jiangnan_java/article/details/39255349</a><br>MySQL数据乱码的解决方法:<a href="http://blog.csdn.net/jiangnan_java/article/details/39255371" target="_blank" rel="external">http://blog.csdn.net/jiangnan_java/article/details/39255371</a><br>root密码重置: <a href="http://blog.csdn.net/jiangnan_java/article/details/39255323" target="_blank" rel="external">http://blog.csdn.net/jiangnan_java/article/details/39255323</a><br>tomcat: tomcat-users.xml中<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">tomcat-users</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">role</span> <span class="attribute">rolename</span>=<span class="value">"manager-gui"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">user</span> <span class="attribute">username</span>=<span class="value">"jiangnan05"</span> <span class="attribute">password</span>=<span class="value">"****"</span> <span class="attribute">roles</span>=<span class="value">"manager-gui"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>阿里云的服务器被入侵，系统卡死。重新搭建服务器，为了防止再出问题记录一下：</p>
<p>JDK安装：<a href="http://www.linuxidc.com/Linux/2014-03/98320.htm" target="_blank" rel="externa]]>
    </summary>
    
      <category term="Linux" scheme="http://jiangnan31.github.io/tags/Linux/"/>
    
      <category term="笔记" scheme="http://jiangnan31.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 多线程<四> 线程的同步与锁(转载)]]></title>
    <link href="http://jiangnan31.github.io/2014/10/30/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9B%9B/"/>
    <id>http://jiangnan31.github.io/2014/10/30/Java-多线程-四/</id>
    <published>2014-10-30T06:22:06.000Z</published>
    <updated>2015-09-05T03:39:27.168Z</updated>
    <content type="html"><![CDATA[<h2 id="一、同步问题提出">一、同步问题提出</h2><p>线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏。<br>例如：两个线程ThreadA、ThreadB都操作同一个对象Foo对象，并修改Foo对象上的数据。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">100</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> x; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">        x = x - y; </span><br><span class="line">        <span class="keyword">return</span> x; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> Foo foo = <span class="keyword">new</span> Foo(); </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        MyRunnable r = <span class="keyword">new</span> MyRunnable(); </span><br><span class="line">        Thread ta = <span class="keyword">new</span> Thread(r, <span class="string">"Thread-A"</span>); </span><br><span class="line">        Thread tb = <span class="keyword">new</span> Thread(r, <span class="string">"Thread-B"</span>); </span><br><span class="line">        ta.start(); </span><br><span class="line">        tb.start(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; </span><br><span class="line">            <span class="keyword">this</span>.fix(<span class="number">30</span>); </span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                Thread.sleep(<span class="number">1</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" : 当前foo对象的x值= "</span> + foo.getX()); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> foo.fix(y); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br>Thread-A : 当前foo对象的x值= 40<br>Thread-B : 当前foo对象的x值= 40<br>Thread-B : 当前foo对象的x值= -20<br>Thread-A : 当前foo对象的x值= -50<br>Thread-A : 当前foo对象的x值= -80<br>Thread-B : 当前foo对象的x值= -80 </p>
<p>Process finished with exit code 0</p>
<p>从结果发现，这样的输出值明显是不合理的。原因是两个线程不加控制的访问Foo对象并修改其数据所致。</p>
<p>如果要保持结果的合理性，只需要达到一个目的，就是将对Foo的访问加以限制，每次只能有一个线程在访问。这样就能保证Foo对象中数据的合理性了。</p>
<p>在具体的Java代码中需要完成一下两个操作：<br>把竞争访问的资源类Foo变量x标识为private；<br>同步哪些修改变量的代码，使用synchronized关键字同步方法或代码。</p>
<h2 id="二、同步和锁定">二、同步和锁定</h2><p>1、锁的原理</p>
<p><span style="color:red">Java中每个对象都有一个内置锁</span></p>
<p><span style="color:red">当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。</span></p>
<p>当程序运行到synchronized同步方法或代码块时才该对象锁才起作用。</p>
<p>一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。</p>
<p><span style="color:red">释放锁是指持锁线程退出了synchronized同步方法或代码块。</span></p>
<p>关于锁和同步，有一下几个要点：<br>1）、只能同步方法，而不能同步变量和类；<br>2）、每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？<br>3）、不必同步类中所有的方法，类可以同时拥有同步和非同步方法。<br>4）、如果两个线程要<span style="color:red">执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法</span>，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。<br>5）、如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。<br>6）、线程睡眠时，它所持的任何锁都不会释放。<br>7）、线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。<br>8）、同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。<br>9）、在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        x = x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，同步方法也可以改写为非同步方法，但功能完全一样的，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果是完全一样的。</p>
<h2 id="三、静态方法同步">三、静态方法同步</h2><p>要同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class)。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      Xxx.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Xxx.class)&#123;</span><br><span class="line">            Xxx.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、如果线程不能不能获得锁会怎么样">四、如果线程不能不能获得锁会怎么样</h2><p>如果线程试图进入同步方法，而其锁已经被占用，则线程在该对象上被阻塞。实质上，线程进入该对象的的一种池中，必须在哪里等待，直到其锁被释放，该线程再次变为可运行或运行为止。</p>
<p>当考虑阻塞时，一定要注意哪个对象正被用于锁定：<br><span style="color:red">1、调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。</span></p>
<p><span style="color:red">2、调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。</span></p>
<p>3、静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。</p>
<p><span style="color:red">4、对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞。</span></p>
<h2 id="五、何时需要同步">五、何时需要同步</h2><p>在多个线程同时访问互斥（可交换）数据时，应该同步以保护数据，<span style="color:red">确保两个线程不会同时修改它。</span></p>
<p>对于非静态字段中可更改的数据，通常使用非静态方法访问。<br>对于静态字段中可更改的数据，通常使用静态方法访问。</p>
<p>如果需要在非静态方法中使用静态字段，或者在静态字段中调用非静态方法，问题将变得非常复杂。</p>
<h2 id="六、线程安全类">六、线程安全类</h2><p>当一个类已经很好的同步以保护它的数据时，这个类就称为“线程安全的”。</p>
<p>即使是线程安全类，也应该特别小心，因为操作的线程是间仍然不一定安全。</p>
<p>举个形象的例子，比如一个集合是线程安全的，有两个线程在操作同一个集合对象，当第一个线程查询集合非空后，删除集合中所有元素的时候。第二个线程也来执行与第一个线程相同的操作，也许在第一个线程查询后，第二个线程也查询出集合非空，但是当第一个执行清除后，第二个再执行删除显然是不对的，因为此时集合已经为空了。<br>看个代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameList</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> List nameList = Collections.synchronizedList(<span class="keyword">new</span> LinkedList()); </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        nameList.add(name); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeFirst</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (nameList.size() &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> (String) nameList.remove(<span class="number">0</span>); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">final</span> NameList nl = <span class="keyword">new</span> NameList(); </span><br><span class="line">        nl.add(<span class="string">"aaa"</span>); </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">NameDropper</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123; </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; </span><br><span class="line">                String name = nl.removeFirst(); </span><br><span class="line">                System.out.println(name); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> NameDropper(); </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> NameDropper(); </span><br><span class="line">        t1.start(); </span><br><span class="line">        t2.start(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然集合对象<br>    private List nameList = Collections.synchronizedList(new LinkedList());<br>是同步的，但是程序还不是线程安全的。<br>出现这种事件的原因是，上例中一个线程操作列表过程中无法阻止另外一个线程对列表的其他操作。</p>
<p>解决上面问题的办法是，在操作集合对象的NameList上面做一个同步。改写后的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameList</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> List nameList = Collections.synchronizedList(<span class="keyword">new</span> LinkedList()); </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        nameList.add(name); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">removeFirst</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (nameList.size() &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> (String) nameList.remove(<span class="number">0</span>); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，当一个线程访问其中一个同步方法时，其他线程只有等待。</p>
<h2 id="七、线程死锁">七、线程死锁</h2><p>死锁对Java程序来说，是很复杂的，也很难发现问题。当两个线程被阻塞，每个线程在等待另一个线程时就发生死锁。</p>
<p>还是看一个比较直观的死锁例子：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadlockRisk</span> </span>{ 
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>{ 
        <span class="keyword">public</span> <span class="keyword">int</span> value; 
    } 

    <span class="keyword">private</span> Resource resourceA = <span class="keyword">new</span> Resource(); 
    <span class="keyword">private</span> Resource resourceB = <span class="keyword">new</span> Resource(); 

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>{ 
        <span class="keyword">synchronized</span> (resourceA) { 
            <span class="keyword">synchronized</span> (resourceB) { 
                <span class="keyword">return</span> resourceB.value + resourceA.value; 
            } 
        } 
    } 

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{ 
        <span class="keyword">synchronized</span> (resourceB) { 
            <span class="keyword">synchronized</span> (resourceA) { 
                resourceA.value = a; 
                resourceB.value = b; 
            } 
        } 
    } 
}
</code></pre>
<p>假设read()方法由一个线程启动，write()方法由另外一个线程启动。读线程将拥有resourceA锁，写线程将拥有resourceB锁，两者都坚持等待的话就出现死锁。</p>
<p>实际上，上面这个例子发生死锁的概率很小。因为在代码内的某个点，CPU必须从读线程切换到写线程，所以，死锁基本上不能发生。</p>
<p>但是，无论代码中发生死锁的概率有多小，一旦发生死锁，程序就死掉。有一些设计方法能帮助避免死锁，包括始终按照预定义的顺序获取锁这一策略。</p>
<h2 id="八、线程同步小结">八、线程同步小结</h2><p>1、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。<br>2、线程同步方法是通过锁来实现，<span style="color:red">每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。</span><br>3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。<span style="color:red">静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。</span><br>4、对于同步，要时刻清醒在哪个对象上同步，这是关键。<br>5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。<br>6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。<br>7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉。<br>转载自：<a href="http://lavasoft.blog.51cto.com/62575/27069/" target="_blank" rel="external">http://lavasoft.blog.51cto.com/62575/27069/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、同步问题提出">一、同步问题提出</h2><p>线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏。<br>例如：两个线程ThreadA、ThreadB都操作同一个对象Foo对象，并修改Foo对象上的数据。<br>]]>
    
    </summary>
    
      <category term="Concurrency" scheme="http://jiangnan31.github.io/tags/Concurrency/"/>
    
      <category term="转载" scheme="http://jiangnan31.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 多线程<三> 线程栈模型与线程的变量&线程状态的转换(转载)]]></title>
    <link href="http://jiangnan31.github.io/2014/10/30/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"/>
    <id>http://jiangnan31.github.io/2014/10/30/Java-多线程-三/</id>
    <published>2014-10-30T01:09:36.000Z</published>
    <updated>2015-09-05T04:36:15.135Z</updated>
    <content type="html"><![CDATA[<h1 id="一、_线程栈模型与线程的变量">一、 线程栈模型与线程的变量</h1><p>要理解线程调度的原理，以及线程执行过程，必须理解线程栈模型。<span style="color:red">(线程调用start()方法之后会启动新的执行线程，他具有新的调用栈)</span><br>线程栈是指某时刻时内存中线程调度的栈信息，<span style="color:red">当前调用的方法总是位于栈顶</span>。线程栈的内容是随着程序的运行动态变化的，因此研究线程栈必须选择一个运行的时刻（实际上指代码运行到什么地方)。</p>
<p>下面通过一个示例性的代码说明线程（调用）栈的变化过程。<br><a id="more"></a><br><img src="/img/thread/3_1.png" alt=""></p>
<p>这幅图描述在代码执行到两个不同时刻1、2时候，虚拟机线程调用栈示意图。</p>
<p>当程序执行到t.start();时候，程序多出一个分支（增加了一个调用栈B），这样，栈A、栈B并行执行。</p>
<p>从这里就可以看出方法调用和线程启动的区别了。</p>
<h1 id="二、_线程状态的转换">二、 线程状态的转换</h1><h2 id="一、线程状态">一、线程状态</h2><p>线程的状态转换是线程控制的基础。线程状态总的可分为五大状态：分别是生、死、可运行、运行、等待/阻塞。用一个图来描述如下：<br><img src="/img/thread/3_2.png" alt=""><br>1、新状态：线程对象已经创建，还没有在其上调用start()方法。</p>
<p>2、可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。<span style="color:red">当start()方法调用时，线程首先进入可运行状态。</span>在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。</p>
<p>3、运行状态：<span style="color:red">线程调度程序</span>从可运行池中选择一个线程作为运行线程时，它所处的状态。这也是线程进入运行状态的唯一一种方式。</p>
<p>4、等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。</p>
<p>5、死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p>
<p>有关详细状态转换图：<br>线程在一定条件下，状态会发生变化。线程变化的状态转换图如下：<br><img src="/img/thread/3_3.png" alt=""><br>1、新建状态（New）：新创建了一个线程对象。<br>2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。<br>3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。<br>4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。<br>阻塞的情况分三种：<br>（一）、<span style="color:red">等待阻塞</span>：运行的线程执行<span style="color:red">wait()</span>方法，JVM会把该线程放入等待池中。<br>（二）、<span style="color:red">同步阻塞</span>：运行的线程在获取对象的同步锁时，若该<span style="color:red">同步锁</span>被别的线程占用，则JVM会把该线程放入锁池中。<br>（三）、<span style="color:red">其他阻塞</span>：运行的线程<span style="color:red">执行sleep()或join()方法，或者发出了I/O请求时</span>，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。<br>5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
<h2 id="二、阻止线程执行">二、阻止线程执行</h2><p>对于线程的阻止，考虑一下三个方面，不考虑IO阻塞的情况：<br>睡眠；<br>等待；<br>因为需要一个对象的锁定而被阻塞。</p>
<h3 id="1、睡眠">1、睡眠</h3><p>Thread.sleep(long millis)和Thread.sleep(long millis, int nanos)静态方法强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。当线程睡眠时，它入睡在某个地方，在苏醒之前不会返回到可运行状态。<span style="color:red">当睡眠时间到期，则返回到可运行状态。</span></p>
<p>线程睡眠的原因：线程执行太快，或者需要强制进入下一轮，因为Java规范不保证合理的轮换。<br>睡眠的实现：调用静态方法。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(123);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;</span><br><span class="line">``` </span><br><span class="line">睡眠的位置：为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠。</span><br><span class="line"></span><br><span class="line">我们可以将一个耗时的操作改为睡眠，以减慢线程的执行。这样，线程在每次执行过程中，总会睡眠3毫秒，睡眠了，其他的线程就有机会执行了。</span><br><span class="line">注意：</span><br><span class="line">1、&lt;span style="color:red"&gt;线程睡眠是帮助所有线程获得运行机会的最好方法。&lt;/span&gt;</span><br><span class="line">2、线程睡眠到期自动苏醒，并返回到&lt;span style="color:red"&gt;可运行状态&lt;/span&gt;，不是运行状态。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。</span><br><span class="line">3、&lt;span style="color:red"&gt;sleep()是静态方法，只能控制当前正在运行的线程。&lt;/span&gt;</span><br><span class="line">###2、线程的优先级和线程让步yield()</span><br><span class="line">线程的让步是通过Thread.yield()来实现的。&lt;span style="color:red"&gt;yield()&lt;/span&gt;方法的作用是：&lt;span style="color:red"&gt;暂停当前正在执行的线程对象，并执行其他线程。&lt;/span&gt;</span><br><span class="line"> </span><br><span class="line">要理解yield()，必须了解线程的优先级的概念。线程总是存在优先级，优先级范围在1~10之间。JVM线程调度程序是基于优先级的抢先调度机制。在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。但这仅仅是大多数情况。</span><br><span class="line"> </span><br><span class="line">&lt;span style="color:red"&gt;注意&lt;/span&gt;：当设计多线程应用程序的时候，一定不要依赖于线程的优先级。因为线程调度优先级操作是没有保障的，只能把线程优先级作用作为一种提高程序效率的方法，但是要保证程序不依赖这种操作。</span><br><span class="line"> </span><br><span class="line">当线程池中线程都具有相同的优先级，调度程序的JVM实现自由选择它喜欢的线程。这时候调度程序的操作有两种可能：一是&lt;span style="color:red"&gt;选择一个线程运行，直到它阻塞或者运行完成为止。&lt;/span&gt;二是&lt;span style="color:red"&gt;时间分片，为池内的每个线程提供均等的运行机会。&lt;/span&gt;</span><br><span class="line"> </span><br><span class="line">设置线程的优先级：线程默认的优先级是创建它的执行线程的优先级。可以通过setPriority(int newPriority)更改线程的优先级。例如：</span><br><span class="line">        Thread t = new MyThread();</span><br><span class="line">        t.setPriority(8);</span><br><span class="line">        t.start();</span><br><span class="line">线程优先级为1~10之间的正整数，JVM从不会改变一个线程的优先级。然而，1~10之间的值是没有保证的。一些JVM可能不能识别10个不同的值，而将这些优先级进行每两个或多个合并，变成少于10个的优先级，则两个或多个优先级的线程可能被映射为一个优先级。</span><br><span class="line"> </span><br><span class="line">线程默认优先级是5，Thread类中有三个常量，定义线程优先级范围：</span><br><span class="line">static int MAX_PRIORITY         线程可以具有的最高优先级。 </span><br><span class="line">static int MIN_PRIORITY         线程可以具有的最低优先级。 </span><br><span class="line">static int NORM_PRIORITY        分配给线程的默认优先级。</span><br><span class="line">### 3、Thread.yield()方法详解</span><br><span class="line"> </span><br><span class="line">Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。</span><br><span class="line">yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</span><br><span class="line">结论：yield()从未导致线程转到等待/睡眠/阻塞状态。&lt;span style="color:red"&gt;在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。&lt;/spn&gt;</span><br><span class="line"> </span><br><span class="line">### 4、join()方法</span><br><span class="line"> 在JDk的API里对于join()方法是：</span><br><span class="line"></span><br><span class="line">join</span><br><span class="line">public final void join() throws InterruptedException Waits for this thread to die. Throws: InterruptedException  - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown.</span><br><span class="line"></span><br><span class="line">&lt;span style="color:red"&gt;即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。&lt;/spn&gt;</span><br><span class="line"></span><br><span class="line">Thread的非静态方法join()让一个主线程B“加入”到另外一个子线程A的尾部。在A执行完毕之前，B不能工作。例如：</span><br><span class="line">```java</span><br><span class="line">        Thread A = new MyThread();</span><br><span class="line">        A.start();</span><br><span class="line">        A.join();</span><br><span class="line">		...</span><br></pre></td></tr></table></figure></p>
<p>说明： <a href="http://www.open-open.com/lib/view/open1371741636171.html" target="_blank" rel="external">这里</a> <a href="http://www.blogjava.net/jnbzwm/articles/330549.html" target="_blank" rel="external">这里</a><br>另外，join()方法还有带超时限制的重载版本。 例如t.join(5000);则让线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态。</p>
<p>线程的加入join()对线程栈导致的结果是<span style="color:red">线程栈</span>发生了变化，当然这些变化都是瞬时的。</p>
<p><img src="/img/thread/3_4.png" alt=""></p>
<p>代码说明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test6.Thread;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">	        <span class="keyword">super</span>(name); </span><br><span class="line">	    &#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">150</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">				ex.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"  :"</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">		MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">"thread1"</span>);</span><br><span class="line">		MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">"thread2"</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		<span class="comment">//t1.join();</span></span><br><span class="line">		t2.start();</span><br><span class="line">		Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"jvm运行结束"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果<br><img src="/img/thread/3_7.png" alt=""></p>
<p>小结<br>到目前位置，介绍了线程离开运行状态的3种方法：<br>1、调用Thread.sleep()：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。<br>2、调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。<br>3、调用join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。</p>
<p>除了以上三种方式外，还有下面几种特殊情况可能使线程离开运行状态：<br>1、线程的run()方法完成。<br>2、在对象上调用wait()方法（不是在线程上调用）。<br>3、线程不能在对象上获得锁定，它正试图运行该对象的方法代码。<br>4、线程调度程序可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由。<br>转载自：<a href="http://lavasoft.blog.51cto.com/62575/27069/" target="_blank" rel="external">http://lavasoft.blog.51cto.com/62575/27069/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、_线程栈模型与线程的变量">一、 线程栈模型与线程的变量</h1><p>要理解线程调度的原理，以及线程执行过程，必须理解线程栈模型。<span style="color:red">(线程调用start()方法之后会启动新的执行线程，他具有新的调用栈)</span><br>线程栈是指某时刻时内存中线程调度的栈信息，<span style="color:red">当前调用的方法总是位于栈顶</span>。线程栈的内容是随着程序的运行动态变化的，因此研究线程栈必须选择一个运行的时刻（实际上指代码运行到什么地方)。</p>
<p>下面通过一个示例性的代码说明线程（调用）栈的变化过程。<br>]]>
    
    </summary>
    
      <category term="Concurrency" scheme="http://jiangnan31.github.io/tags/Concurrency/"/>
    
      <category term="转载" scheme="http://jiangnan31.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 多线程<二> 创建与启动(转载)]]></title>
    <link href="http://jiangnan31.github.io/2014/10/29/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C/"/>
    <id>http://jiangnan31.github.io/2014/10/29/Java-多线程-二/</id>
    <published>2014-10-29T11:58:29.000Z</published>
    <updated>2015-09-05T04:37:14.264Z</updated>
    <content type="html"><![CDATA[<h2 id="一、定义线程">一、定义线程</h2><h3 id="1、扩展java-lang-Thread类。">1、扩展java.lang.Thread类。</h3><p>此类中有个run()方法，应该注意其用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果该线程是使用独立的 Runnable 运行对象构造的，启动该线程则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。（<span style="color:red">怎么样算使用非独立的 Runnable 运行对象构造？</span>）<br><a id="more"></a><br>Thread 的子类应该重写该方法。</p>
<h3 id="2、实现java-lang-Runnable接口。">2、实现java.lang.Runnable接口。</h3><p>void run()<br>使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run 方法。</p>
<p>方法 run 的常规协定是，它可能执行任何所需的操作。</p>
<h2 id="二、实例化线程">二、实例化线程</h2><h3 id="1、如果是扩展java-lang-Thread类的线程，则直接new即可。">1、如果是扩展java.lang.Thread类的线程，则直接new即可。</h3><h3 id="2、如果是实现了java-lang-Runnable接口的类，则用Thread的构造方法：">2、如果是实现了java.lang.Runnable接口的类，则<span style="color:red">用Thread的构造方法</span>：</h3><p>Thread(Runnable target)<br>Thread(Runnable target, String name)<br>Thread(ThreadGroup group, Runnable target)<br>Thread(ThreadGroup group, Runnable target, String name)<br>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</p>
<h2 id="三、启动线程"><span style="color:red">三、启动线程</span></h2><p>在线程的Thread对象上调用start()方法，而不是run()或者别的方法。</p>
<p>在调用start()方法之前：<span style="color:red">线程处于新状态中，新状态指有一个Thread对象，但还没有一个真正的线程。</span></p>
<p>在调用start()方法之后：发生了一系列复杂的事情<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op=&#62;operation: &#21551;&#21160;&#26032;&#30340;&#25191;&#34892;&#32447;&#31243;&#10;op1=&#62;operation: &#35813;&#32447;&#31243;&#20174;&#26032;&#29366;&#24577;&#36716;&#31227;&#21040;&#21487;&#36816;&#34892;&#29366;&#24577;&#10;op2=&#62;operation:  &#24403;&#35813;&#32447;&#31243;&#33719;&#24471;&#26426;&#20250;&#25191;&#34892;&#26102;&#65292;&#20854;&#30446;&#26631;run()&#26041;&#27861;&#23558;&#36816;&#34892;&#10;op-&#62;op1-&#62;op2</span><br></pre></td></tr></table></figure></p>
<p>注：启动新的执行线程（具有<span style="color:red">新的调用栈</span>）</p>
<p>注意：对Java来说，run()方法没有任何特别之处。像main()方法一样，它只是新线程知道调用的方法名称(和签名)。因此，在Runnable上或者Thread上调用run方法是合法的。但<span style="color:red">并不启动新的线程</span>。</p>
<h2 id="四、实例">四、实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test6.Thread;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="title">TestThread1</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">	        <span class="keyword">this</span>.name = name;</span><br><span class="line">	    &#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">				ex.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(name+<span class="string">"   :"</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="title">TestThread2</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">	        <span class="keyword">super</span>(name); </span><br><span class="line">	    &#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">150</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">				ex.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"  :"</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadRunnableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	    System.out.println(<span class="string">"主线程信息："</span>+Thread.currentThread().getId() +<span class="string">"  "</span>+ Thread.currentThread().getName());</span><br><span class="line">		Runnable  t1 = <span class="keyword">new</span> TestThread1(<span class="string">"thread1"</span>);</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(t1);</span><br><span class="line">		thread1.start();</span><br><span class="line">		</span><br><span class="line">		Runnable  t2 = <span class="keyword">new</span> TestThread2(<span class="string">"thread2"</span>);</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(t2);</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、一些常见问题">五、一些常见问题</h2><p>1、线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是main，非主线程的名字不确定。<br>2、线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。<br>3、获取当前线程的对象的方法是：Thread.currentThread()；<br>4、在上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。<br>5、<span style="color:red">当线程目标run()方法结束时该线程完成。</span><br>6、<span style="color:red">一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动。</span><br>7、线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。<br>众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。<br>8、尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为<span style="color:red">可运行池</span>而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列成一个队列的事实。<br>9、尽管我们没有无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</p>
<p>转载自：<a href="http://lavasoft.blog.51cto.com/62575/27069/" target="_blank" rel="external">http://lavasoft.blog.51cto.com/62575/27069/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、定义线程">一、定义线程</h2><h3 id="1、扩展java-lang-Thread类。">1、扩展java.lang.Thread类。</h3><p>此类中有个run()方法，应该注意其用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果该线程是使用独立的 Runnable 运行对象构造的，启动该线程则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。（<span style="color:red">怎么样算使用非独立的 Runnable 运行对象构造？</span>）<br>]]>
    
    </summary>
    
      <category term="Concurrency" scheme="http://jiangnan31.github.io/tags/Concurrency/"/>
    
      <category term="转载" scheme="http://jiangnan31.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDFS架构简介(转载)]]></title>
    <link href="http://jiangnan31.github.io/2014/10/29/HDFS%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"/>
    <id>http://jiangnan31.github.io/2014/10/29/HDFS架构简介/</id>
    <published>2014-10-29T07:24:49.000Z</published>
    <updated>2015-09-05T04:38:14.170Z</updated>
    <content type="html"><![CDATA[<h2 id="一-_HDFS框架简述">一. HDFS框架简述</h2><p><img src="/img/Hadoop/1.jpg" alt=""><br><a id="more"></a><br>HDFS设计目标:</p>
<ol>
<li>容错性</li>
<li>流式数据访问</li>
<li>大规模数据集</li>
<li>简单的一致性模型</li>
<li>移动计算到数据附近</li>
<li>可移植性</li>
</ol>
<h2 id="二-_HDFS分解简述">二. HDFS分解简述</h2><h3 id="NameNode_/_DataNode">NameNode / DataNode</h3><p>HDFS采用Master/Slave架构，HDFS集群是由一个NameNode和多个DataNodes组成。<span style="color:red">NameNode是中心服务器，负责管理文件系统的名字空间(namespace)以及客户端的访问。</span>DataNode负责管理它所在节点上的存储。用户能够通过HDFS文件系统的名字空间以文件的形式在上面存储数据。</p>
<p>对于内部存储，一个文件被切分为一个或多个块，存储在一组DataNode上。<span style="color:red">NameNode执行文件系统的名字空间操作</span>，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体DataNode节点的映射。</p>
<h3 id="数据存储副本容错">数据存储副本容错</h3><p>HDFS文件的所有数据块都会有副本。每个文件的数据块大小和副本系数都是可配置的。HDFS中的文件都是一次性写入的，并且在任何时候只能有一个写入者。<br><span style="color:red">NameNode全权管理数据块的复制</span>，它周期性地从集群中的每个DataNode接收心跳信号和块状态报告(Block Report)。块状态报告包含了一个该DataNode上所有数据块的列表。</p>
<p><img src="/img/Hadoop/2.jpg" alt=""></p>
<h3 id="副本放置策略">副本放置策略</h3><p>副本的放置策略是区分文件系统的重要特性之一，也是HDFS性能和可靠性的关键，HDFS采用了<span style="color:red"><strong>机架感知(rack-aware)的策略</strong></span>来存储副本。 文件写流程可以参考<a href="http://flyingdutchman.iteye.com/blog/1874713" target="_blank" rel="external">这里</a>  <a href="http://hpuxtbjvip0.blog.163.com/blog/static/367413132013314105119419/" target="_blank" rel="external">这里</a></p>
<p>在大多数情况下，副本系数是3，HDFS的存放策略是将一个副本存放在本地机架的节点上，一个副本放在同一机架的另一个节点上，最后一个副本放在不同机架的节点上。这种策略减少了机架间的数据传输，这就提高了写操作的效率。整个机架的错误远远比单个节点的错误少，所以这个策略不会影响到数据的可靠性和可用性。于此同时，因为数据块只放在两个（不是三个）不同的机架上，所以此策略减少了读取数据时需要的网络传输总带宽。在这种策略下，副本并不是均匀分布在不同的机架上。三分之一的副本在一个节点上，三分之二的副本在一个机架上，如果大于3个副本，其他副本均匀分布在剩下的机架中，这一策略在不损害数据可靠性和读取性能的情况下改进了写的性能。</p>
<h3 id="机架感知">机架感知</h3><p>一个大型集群大多会被分为多个机架(Rack)，一个机架包含多个节点，一般来说，机架内部机器的通信速度要高于机架之间的通信速度，而且往往机架之间的通信受到上层交换机等的带宽限制。</p>
<p>HDFS中，对机架的感知并非是自适应的，即机架的配置是由配置文件决定，并且是人工指定的，这些rackid信息可以通过topology.script.file.name配置，通过IP到机架id的映射指定哪些节点属于哪个机架，在NameNode启动时将配置信息读取到内存中，保存在一个map中。</p>
<p>通过机架感知，NameNode就可以画出DataNode以及交换机等节点的<span style="color:red">网络拓扑图</span>，通过拓扑图就可以计算出任意两个DataNode之间的距离，得到最优的存放策略，优化整个集群的网络带宽均衡以及数据最优分配。</p>
<h3 id="安全模式">安全模式</h3><p>安全模式是指NameNode的一种特殊状态。处于安全模式的NameNode是不进行数据块的复制的。NameNode从所有的 DataNode接收心跳信号和块状态报告。当Namenode检测确认某个数据块的副本数目达到该数据块的最小副本数，那么该数据块会被认为是副本安全(safely replicated)的。<br>Namenode退出安全模式状态后，它会确定哪些数据块的副本没有达到指定数目，并将这些数据块复制到其他DataNode上。</p>
<h3 id="元数据持久化">元数据持久化</h3><p>HDFS通过dfs.name.dir这个参数设置HDFS的元数据信息存放在NameNode本地操作系统的目录，目录里通常包括以下文件：edits 、FsImage、 FsTime、VERSION</p>
<h3 id="EditLog">EditLog</h3><p>Namenode用edits文件来保存对元数据进行的每次操作，比如创建文件，删除 文件，修改文件的副本系数。类似于mysql中的binlog机制。</p>
<p>###SecondNameNode </p>
<p>SecondNamenode其实只是一个简单的元数据备份 进程，它会定期（缺省是1小时）把edits文件的内容合并到fsimage文件，同时保存最新的元数据副本在SecondNamenode进程所在机器的文件系统里。</p>
<h3 id="FileImage">FileImage</h3><p>整个文件系统的名字空间，包括数据块到文件的映射、文件的属性等，都存储在FsImage的文件中，FsImage结合edits才能准确表示内存中的元数据信息。</p>
<p>当NameNode启动时，它从硬盘中读取Editlog和FsImage，将所有Editlog中的事务作用合并到内存中的FsImage上，并将这个新版本的FsImage从内存中保存到本地磁盘上，然后删除旧的Editlog，因为这个旧的Editlog的事务都已经作用在FsImage上了。这个过程称为一个检查点(checkpoint)，在当前实现中，检查点只发生在NameNode启动时，在不久的将来将实现支持周期性的检查点，此时这个时候系统处于安全模式，NameNode等待DataNode上报各自的block 数据块信息。</p>
<h3 id="Format_HDFS系统">Format  HDFS系统</h3><p>hadoop namenode -format命令用来初始化HDFS系统，事实就是初始化dfs.name.dir目录中的四个文件edits，FsImage，FsTime ，VERSION。</p>
<h3 id="故障容错">故障容错</h3><h3 id="DataNode数据复制">DataNode数据复制</h3><p>每个DataNode周期性地向NameNode发送心跳。网络割裂可能导致部分DataNode跟NameNode失去联系。NameNode将近期不发送心跳信号DataNode标记为宕机，不会再将新的IO请求发给它们。NameNode通过复制操作将新的副本复制到有效的DataNode。<br>在下列情况下，可能需要重新复制：某个DataNode节点失效，某个副本遭到损坏，DataNode上的硬盘错误，或者文件的副本系数增大。</p>
<h3 id="集群均衡">集群均衡</h3><p>HDFS的架构支持数据均衡策略。如果某个DataNode节点上的空闲空间低于特定的临界点，系统就会自动地将数据从该DataNode移动到其他DataNode。当对某个文件的请求突然增加，那么也可能启动一个计划创建该文件新的副本，并且同时重新平衡集群中的其他数据。这些均衡策略目前还没有实现。<br>数据完整性</p>
<p>HDFS客户端实现了对HDFS文件内容的校验和(checksum)检查。当客户端创建一个新的HDFS文件，会计算这个文件每个数据块的校验和，并将校验和作为一个单独的隐藏文件保存在同一个HDFS名字空间下。当客户端获取文件内容后，它会校验文件的完整性，如果数据错误，客户端可以选择从其他DataNode获取该数据块的副本。</p>
<h3 id="元数据错误">元数据错误</h3><p>FsImage和Editlog是HDFS的核心数据结构，如果损坏了，整个HDFS都将失效。因而，NameNode可以配置成支持维护多个FsImage和Editlog的副本。任何对FsImage或者Editlog的修改，都将同步到它们的副本上。这种多副本的同步操作可能会降低NameNode每秒处理的名字空间事务数量。然而这个代价是可以接受的，因为即使HDFS的应用是数据密集的，它们也非元数据密集的。当NameNode重启的时候，它会选取最近的完整的FsImage和Editlog来使用。</p>
<p>NameNode是HDFS集群中的单点故障(single point of failure)所在。如果NameNode机器故障，是需要手工干预的。目前，自动重启或在另一台机器上做NameNode故障转移的功能还没实现。</p>
<h3 id="快照">快照</h3><p>快照支持某一特定时刻的数据的复制备份。利用快照，可以让HDFS在数据损坏时恢复到过去一个已知正确的时间点。HDFS目前还不支持快照功能，但计划在将来的版本进行支持。</p>
<h3 id="数据模型">数据模型</h3><h3 id="数据分段">数据分段</h3><p>创建文件时以及写数据时，客户端的请求其实并没有立即发送给NameNode，事实上，HDFS客户端会先将文件数据缓存到本地的一个临时文件。写操作被透明地重定向到这个临时文，当临时文件的数据量超过一个数据块的大小，客户端才会联系NameNode。NameNode将文件名插入文件系统的层次结构中，并且分配一个数据块给它。然后返回DataNode的标识符和目标数据块给客户端。客户端再将数据从本地临时文件上传到指定的DataNode上。</p>
<p>当文件关闭时，在临时文件中没有上传的数据也会传输到指定的DataNode上，客户端会告诉NameNode文件已经关闭。此时NameNode才将文件创建操作提交到日志里进行存储。如果NameNode在文件关闭前宕机了，则该文件将丢失。</p>
<p>上述方法是对在HDFS上运行的目标应用进行认真考虑后得到的结果。这些应用需要进行文件的流式写入。如果不采用客户端缓存，由于网络速度和网络堵塞会对吞估量造成比较大的影响。</p>
<h3 id="流水线复制">流水线复制</h3><p>客户端向HDFS文件写入数据时，首先写入本地临时文件，假设该文件的副本系数为3，当本地临时文件累积到一个数据块的大小时，客户端会从NameNode获取一个DataNode列表用于存放副本，然后客户端向第一个DataNode传输数据，第一个DataNode一小部分一小部分(4 KB)地接收数据并写入本地仓库，并同时传输该部分到列表中第二个DataNode节点。第二个DataNode接收数据，并同时传给第三个DataNode。因此，DataNode能流水线式地从前一个节点接收数据，并在同时转发给下一个节点，数据以流水线的方式从前一个DataNode复制到下一个</p>
<h3 id="简单一致性模型">简单一致性模型</h3><p>HDFS主要应用于大规模的数据处理，一个数据集通常由数据源生成或复制，在此基础上进行各种分析。每个分析至少都会涉及数据集中的大部分数据 (甚至全部)，因此读取整个数据集的时间比读取第一条记录的延迟更为重要。</p>
<p>因此HDFS对文件操作需要的是一次写入，多次读取的。一个文件一旦创建、写入、关闭之后就不需要修改了。这个假定简化了数据一致的问题和高吞吐量的数据访问。文件的修改、写操作只能append（），在文件的末尾增加，它不支持在文件的任意位置修改。</p>
<p>转载自： <a href="http://asyty-cp.blog.163.com/blog/static/117542439201191322858356/" target="_blank" rel="external">http://asyty-cp.blog.163.com/blog/static/117542439201191322858356/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一-_HDFS框架简述">一. HDFS框架简述</h2><p><img src="/img/Hadoop/1.jpg" alt=""><br>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://jiangnan31.github.io/tags/Hadoop/"/>
    
      <category term="转载" scheme="http://jiangnan31.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 多线程<一> 概念与原理(转载)]]></title>
    <link href="http://jiangnan31.github.io/2014/10/28/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/"/>
    <id>http://jiangnan31.github.io/2014/10/28/Java-多线程-一/</id>
    <published>2014-10-28T09:11:13.000Z</published>
    <updated>2015-09-05T04:35:30.901Z</updated>
    <content type="html"><![CDATA[<h2 id="一、操作系统中线程和进程的概念">一、操作系统中线程和进程的概念</h2><p>现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。</p>
<p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。</p>
<p>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。“同时”执行是人的感觉，在线程之间实际上轮换执行。<br><a id="more"></a><br>多线程的目的是为了<span style="color:red">最大限度的利用CPU资源。</span></p>
<p>Java编写程序都运行在在Java虚拟机（JVM）中，在JVM的内部，程序的多任务是通过线程来实现的。每用java命令启动一个java应用程序，就会启动一个JVM进程。在同一个JVM进程中，有且只有一个进程，就是它自己。在这个JVM环境中，所有程序代码的运行都是以线程来运行。</p>
<p>一般常见的Java应用程序都是单线程的。<span style="color:red">比如，用java命令运行一个最简单的HelloWorld的Java应用程序时，就启动了一个JVM进程，JVM找到程序程序的入口点main()，然后运行main()方法，这样就产生了一个线程，这个线程称之为主线程。当main方法结束后，主线程运行完成。JVM进程也随即退出。</span></p>
<p>实际上，操作的系统的多进程实现了多任务并发执行，程序的多线程实现了进程的并发执行(？)。多任务、多进程、多线程的前提都是要求操作系统提供多任务、多进程、多线程的支持。</p>
<h2 id="二、Java中的线程">二、Java中的线程</h2><p>在Java中，“线程”指两件不同的事情：<br>1、java.lang.Thread类的一个实例。<br>2、线程的执行。</p>
<p>使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。</p>
<p>一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。</p>
<p>Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。</p>
<p>一个Java应用总是从main()方法开始运行，mian()方法运行在一个线程内，它被称为主线程。</p>
<p><span style="color:red">一旦创建一个新的线程，就产生一个新的调用栈。</span></p>
<p>线程总体分两类：用户线程和守候线程。</p>
<p>当所有用户线程执行完毕的时候，JVM自动关闭。但是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的。（两者唯一区别: 如果User Thread全部撤离，那么Daemon Thread也就没啥线程好服务的了，所以虚拟机也就退出了）。守护线程&amp;非守护线程参考： <a href="http://www.cnblogs.com/super-d2/p/3348183.html" target="_blank" rel="external">这里</a><br>例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test5.DaemonThread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">				ex.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"TestThread1:"</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">				ex.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"TestThread2:"</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo2</span>  </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestThread1 test1 = <span class="keyword">new</span> TestThread1();</span><br><span class="line">		TestThread2 test2 = <span class="keyword">new</span> TestThread2();</span><br><span class="line">		test1.setDaemon(<span class="keyword">false</span>);<span class="comment">// 用户线程,必须结束后才能退出JVM</span></span><br><span class="line">		test2.setDaemon(<span class="keyword">true</span>);<span class="comment">// 守护线程，不需要结束</span></span><br><span class="line">		System.out.println(<span class="string">" test1  isDaemon:"</span> + test1.isDaemon());</span><br><span class="line">		System.out.println(<span class="string">" test2  isDaemon:"</span> + test2.isDaemon());</span><br><span class="line">		test1.start();</span><br><span class="line">		test2.start();</span><br><span class="line">		Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"jvm运行结束"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="/img/thread/1.png" alt=""><br>从结果可以看出，jvm不必等守护线程执行完成再退出，用户线程执行完毕便可以自动关闭。<br>附：<br>Runtime.getRuntime().addShutdownHook(shutdownHook);<br>   这个方法的含义说明：<br>    这个方法的意思就是在jvm中增加一个关闭的钩子，当jvm关闭的时候，会执行系统中已经设置的所有通过方法addShutdownHook添加的钩子，当系统执行完这些钩子后，jvm才会关闭。所以这些钩子可以在jvm关闭的时候进行内存清理、对象销毁等操作。<br>转载自：<a href="http://lavasoft.blog.51cto.com/62575/27069/" target="_blank" rel="external">http://lavasoft.blog.51cto.com/62575/27069/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、操作系统中线程和进程的概念">一、操作系统中线程和进程的概念</h2><p>现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。</p>
<p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。</p>
<p>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。“同时”执行是人的感觉，在线程之间实际上轮换执行。<br>]]>
    
    </summary>
    
      <category term="Concurrency" scheme="http://jiangnan31.github.io/tags/Concurrency/"/>
    
      <category term="转载" scheme="http://jiangnan31.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Future、FutureTask、Callable]]></title>
    <link href="http://jiangnan31.github.io/2014/10/28/Future%E3%80%81FutureTask%E3%80%81Callable/"/>
    <id>http://jiangnan31.github.io/2014/10/28/Future、FutureTask、Callable/</id>
    <published>2014-10-28T05:13:50.000Z</published>
    <updated>2015-09-05T04:39:18.039Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_Future接口">1. Future接口</h2><p>JDK API中的说明<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span> &lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p> Future表示异步计算的结果。<span style="color:red">它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。</span>计算完成后只能使用 get 方法来获取结果，如有必要，计算完成前可以阻塞此方法。<span style="color:red">取消则由cancel方法来执行。</span>还提供了其他方法，以确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。<br><a id="more"></a><br>方法：<br>（1）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span></span><br></pre></td></tr></table></figure></p>
<p>试图取消对此任务的执行。如果任务已完成、或已取消，或者由于某些其他原因而无法取消，则此尝试将失败。当调用 cancel 时，如果调用成功，而此任务尚未启动，则此任务将永不运行。如果任务已经启动，则 mayInterruptIfRunning 参数确定<span style="color:red">是否应该以试图停止任务的方式来中断执行此任务的线程。</span> 此方法返回后，对 isDone() 的后续调用将始终返回 true。如果此方法返回 true，则对 isCancelled() 的后续调用将始终返回 true。<br>(2)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果在任务正常完成前将其取消，则返回 true。<br>(3)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true。<br>(4)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,ExecutionException</span></span><br></pre></td></tr></table></figure></p>
<p>如有必要，等待计算完成，然后<span style="color:red">获取其结果。</span><br>(5)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException,ExecutionException,TimeoutException</span></span><br></pre></td></tr></table></figure></p>
<p>如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。 </p>
<h2 id="2-_RunnableFuture接口">2. RunnableFuture接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>作为 Runnable 的 Future。成功执行 run 方法可以完成 Future 并允许访问其结果。</p>
<p>继承了Runnable方法和Future方法，所以实现了这个接口的类可以被多线程下执行，并且能够异步的取得结果。</p>
<h2 id="3-_Callable接口">3. Callable接口</h2><p>callable接口与Runnable接口非常相似，他们都是为潜在的可能被多线程调用的类所设计。但是callable的call（）方法是有返回值的，而且可以抛出一个Check Exception异常。</p>
<h2 id="4-_Runnable接口">4. Runnable接口</h2><p>Runnable接口：这个接口是我们非常熟悉的，在这个接口中只有一个run（）方法，在这个方法中我们可以实现我们的计算逻辑。但是没有返回值，也就是说runnable接口只管运行，不管运行结果。</p>
<h2 id="5-_FutureTask">5. FutureTask</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>FutureTask类是Future的一个实现，并实现了Runnable，所以可通过 Excutor和Thread对象执行。</p>
<p>下面的例子可以做为参考：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Changgong</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hours=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> amount;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(hours&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"I'm working......  "</span>+hours+<span class="string">" hours"</span>);</span><br><span class="line">            amount ++;</span><br><span class="line">            hours--;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dizhu</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Changgong worker = <span class="keyword">new</span> Changgong();</span><br><span class="line">        FutureTask&lt;Integer&gt; jiangong = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(worker);</span><br><span class="line">        <span class="keyword">new</span> Thread(jiangong).start();</span><br><span class="line">        <span class="keyword">while</span>(!jiangong.isDone())&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"看长工做完了没..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> amount;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            amount = jiangong.get();</span><br><span class="line">            System.out.println(<span class="string">"工作做完了,上交了"</span>+amount);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>看长工做完了没…<br>I’m working……  12 hours<br>看长工做完了没…<br>I’m working……  11 hours<br>看长工做完了没…<br>I’m working……  10 hours<br>看长工做完了没…<br>I’m working……  9 hours<br>看长工做完了没…<br>I’m working……  8 hours<br>看长工做完了没…<br>I’m working……  7 hours<br>看长工做完了没…<br>I’m working……  6 hours<br>看长工做完了没…<br>I’m working……  5 hours<br>看长工做完了没…<br>I’m working……  4 hours<br>看长工做完了没…<br>I’m working……  3 hours<br>看长工做完了没…<br>I’m working……  2 hours<br>看长工做完了没…<br>I’m working……  1 hours<br>看长工做完了没…<br>工作做完了,上交了12</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_Future接口">1. Future接口</h2><p>JDK API中的说明<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span> &lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p> Future表示异步计算的结果。<span style="color:red">它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。</span>计算完成后只能使用 get 方法来获取结果，如有必要，计算完成前可以阻塞此方法。<span style="color:red">取消则由cancel方法来执行。</span>还提供了其他方法，以确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。<br>]]>
    
    </summary>
    
      <category term="Concurrency" scheme="http://jiangnan31.github.io/tags/Concurrency/"/>
    
      <category term="笔记" scheme="http://jiangnan31.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetCode系列<一>]]></title>
    <link href="http://jiangnan31.github.io/2014/10/22/leetCode%E7%B3%BB%E5%88%97-%E4%B8%80/"/>
    <id>http://jiangnan31.github.io/2014/10/22/leetCode系列-一/</id>
    <published>2014-10-22T11:32:12.000Z</published>
    <updated>2015-09-05T04:35:18.945Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_Two_Sum">1. Two Sum</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * </span><br><span class="line">* <span class="doctag">@ClassName</span>: TwoSumTest</span><br><span class="line">* <span class="doctag">@add</span> date  2011-03-13</span><br><span class="line">* <span class="doctag">@Description</span>: Given an array of integers, find two numbers such that they add up to a specific target number.</span><br><span class="line">* The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</span><br><span class="line">* You may assume that each input would have exactly one solution.</span><br><span class="line">* Input: numbers=&#123;2, 7, 11, 15&#125;, target=9</span><br><span class="line">* Output: index1=1, index2=2</span><br><span class="line">* <span class="doctag">@author</span> jiangnan04 </span><br><span class="line">* <span class="doctag">@date</span> 2014-10-22 下午08:44:15 </span><br><span class="line">*</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSumTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    	 HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();  </span><br><span class="line">         <span class="keyword">int</span> n = numbers.length;  </span><br><span class="line">         <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];  </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)  </span><br><span class="line">         &#123;  </span><br><span class="line">             <span class="keyword">if</span> (map.containsKey(target - numbers[i]))  </span><br><span class="line">             &#123;  </span><br><span class="line">                 result[<span class="number">0</span>] = map.get(target-numbers[i]) + <span class="number">1</span>;  </span><br><span class="line">                 result[<span class="number">1</span>] = i + <span class="number">1</span>;  </span><br><span class="line">                 <span class="keyword">break</span>;  </span><br><span class="line">             &#125;  </span><br><span class="line">             <span class="keyword">else</span>  </span><br><span class="line">             &#123;  </span><br><span class="line">                 map.put(numbers[i], i);  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TwoSumTest t1 = <span class="keyword">new</span> TwoSumTest();</span><br><span class="line">		<span class="comment">//int []numbers=&#123;2, 7, 11, 15&#125;;</span></span><br><span class="line">		<span class="keyword">int</span> []numbers=&#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>&#125;;</span><br><span class="line">		<span class="comment">//int [] numbers=&#123;5,75,25&#125;;</span></span><br><span class="line">		<span class="keyword">int</span> target=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span>[] reslut = t1.twoSum(numbers,target);</span><br><span class="line">		System.out.println(reslut[<span class="number">0</span>]+<span class="string">"  "</span>+ reslut[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_Two_Sum">1. Two Sum</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span cl]]>
    </summary>
    
      <category term="LeetCode" scheme="http://jiangnan31.github.io/tags/LeetCode/"/>
    
      <category term="Code" scheme="http://jiangnan31.github.io/categories/Code/"/>
    
  </entry>
  
</feed>
